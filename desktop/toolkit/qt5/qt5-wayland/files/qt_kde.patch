diff --git a/src/client/global/qwaylandclientextension.cpp b/src/client/global/qwaylandclientextension.cpp
index 125b1e19..edccfe63 100644
--- a/src/client/global/qwaylandclientextension.cpp
+++ b/src/client/global/qwaylandclientextension.cpp
@@ -74,7 +74,10 @@ void QWaylandClientExtensionPrivate::handleRegistryGlobal(void *data, ::wl_regis
 void QWaylandClientExtension::addRegistryListener()
 {
     Q_D(QWaylandClientExtension);
-    d->waylandIntegration->display()->addRegistryListener(&QWaylandClientExtensionPrivate::handleRegistryGlobal, this);
+    if (!d->registered) {
+        d->waylandIntegration->display()->addRegistryListener(&QWaylandClientExtensionPrivate::handleRegistryGlobal, this);
+        d->registered = true;
+    }
 }
 
 QWaylandClientExtension::QWaylandClientExtension(const int ver)
@@ -88,6 +91,13 @@ QWaylandClientExtension::QWaylandClientExtension(const int ver)
     QMetaObject::invokeMethod(this, "addRegistryListener", Qt::QueuedConnection);
 }
 
+QWaylandClientExtension::~QWaylandClientExtension()
+{
+    Q_D(QWaylandClientExtension);
+    if (d->registered && !QCoreApplication::closingDown())
+        d->waylandIntegration->display()->removeListener(&QWaylandClientExtensionPrivate::handleRegistryGlobal, this);
+}
+
 QtWaylandClient::QWaylandIntegration *QWaylandClientExtension::integration() const
 {
     Q_D(const QWaylandClientExtension);
diff --git a/src/client/global/qwaylandclientextension.h b/src/client/global/qwaylandclientextension.h
index 98272e57..5bd28398 100644
--- a/src/client/global/qwaylandclientextension.h
+++ b/src/client/global/qwaylandclientextension.h
@@ -63,6 +63,7 @@ class Q_WAYLAND_CLIENT_EXPORT QWaylandClientExtension : public QObject
     Q_PROPERTY(bool active READ isActive NOTIFY activeChanged)
 public:
     QWaylandClientExtension(const int version);
+    ~QWaylandClientExtension();
 
     QtWaylandClient::QWaylandIntegration *integration() const;
     int version() const;
diff --git a/src/client/global/qwaylandclientextension_p.h b/src/client/global/qwaylandclientextension_p.h
index 69cc46a0..9091efbe 100644
--- a/src/client/global/qwaylandclientextension_p.h
+++ b/src/client/global/qwaylandclientextension_p.h
@@ -68,6 +68,7 @@ public:
     QtWaylandClient::QWaylandIntegration *waylandIntegration = nullptr;
     int version = -1;
     bool active = false;
+    bool registered = false;
 };
 
 class Q_WAYLAND_CLIENT_EXPORT QWaylandClientExtensionTemplatePrivate : public QWaylandClientExtensionPrivate
diff --git a/src/client/qwaylandabstractdecoration.cpp b/src/client/qwaylandabstractdecoration.cpp
index 87dd6cea..b6ee43c9 100644
--- a/src/client/qwaylandabstractdecoration.cpp
+++ b/src/client/qwaylandabstractdecoration.cpp
@@ -108,11 +108,11 @@ void QWaylandAbstractDecoration::setWaylandWindow(QWaylandWindow *window)
 static QRegion marginsRegion(const QSize &size, const QMargins &margins)
 {
     QRegion r;
-    const int widthWithMargins = margins.left() + size.width() + margins.right();
-    r += QRect(0, 0, widthWithMargins, margins.top()); // top
-    r += QRect(0, size.height()+margins.top(), widthWithMargins, margins.bottom()); //bottom
+
+    r += QRect(0, 0, size.width(), margins.top()); // top
+    r += QRect(0, size.height()-margins.bottom(), size.width(), margins.bottom()); //bottom
     r += QRect(0, margins.top(), margins.left(), size.height()); //left
-    r += QRect(size.width()+margins.left(), margins.top(), margins.right(), size.height()); // right
+    r += QRect(size.width()-margins.left(), margins.top(), margins.right(), size.height()-margins.top()); // right
     return r;
 }
 
diff --git a/src/client/qwaylanddatadevice.cpp b/src/client/qwaylanddatadevice.cpp
index 19944a34..bbd2d568 100644
--- a/src/client/qwaylanddatadevice.cpp
+++ b/src/client/qwaylanddatadevice.cpp
@@ -124,6 +124,7 @@ bool QWaylandDataDevice::startDrag(QMimeData *mimeData, QWaylandWindow *icon)
 
     m_dragSource.reset(new QWaylandDataSource(m_display->dndSelectionHandler(), mimeData));
     connect(m_dragSource.data(), &QWaylandDataSource::cancelled, this, &QWaylandDataDevice::dragSourceCancelled);
+    connect(m_dragSource.data(), &QWaylandDataSource::targetChanged, this, &QWaylandDataDevice::dragSourceTargetChanged);
 
     start_drag(m_dragSource->object(), origin->wlSurface(), icon->wlSurface(), m_display->currentInputDevice()->serial());
     return true;
@@ -168,7 +169,7 @@ void QWaylandDataDevice::data_device_drop()
 
 void QWaylandDataDevice::data_device_enter(uint32_t serial, wl_surface *surface, wl_fixed_t x, wl_fixed_t y, wl_data_offer *id)
 {
-    auto *dragWaylandWindow = QWaylandWindow::fromWlSurface(surface);
+    auto *dragWaylandWindow = surface ? QWaylandWindow::fromWlSurface(surface) : nullptr;
     if (!dragWaylandWindow)
         return; // Ignore foreign surfaces
 
diff --git a/src/client/qwaylanddisplay.cpp b/src/client/qwaylanddisplay.cpp
index fe094f6f..9f595af3 100644
--- a/src/client/qwaylanddisplay.cpp
+++ b/src/client/qwaylanddisplay.cpp
@@ -206,10 +206,11 @@ void QWaylandDisplay::checkError() const
     int ecode = wl_display_get_error(mDisplay);
     if ((ecode == EPIPE || ecode == ECONNRESET)) {
         // special case this to provide a nicer error
-        qFatal("The Wayland connection broke. Did the Wayland compositor die?");
+        qWarning("The Wayland connection broke. Did the Wayland compositor die?");
     } else {
-        qFatal("The Wayland connection experienced a fatal error: %s", strerror(ecode));
+        qWarning("The Wayland connection experienced a fatal error: %s", strerror(ecode));
     }
+    _exit(1);
 }
 
 void QWaylandDisplay::flushRequests()
@@ -451,9 +452,10 @@ void QWaylandDisplay::addRegistryListener(RegistryListener listener, void *data)
 
 void QWaylandDisplay::removeListener(RegistryListener listener, void *data)
 {
-    std::remove_if(mRegistryListeners.begin(), mRegistryListeners.end(), [=](Listener l){
+    auto iter = std::remove_if(mRegistryListeners.begin(), mRegistryListeners.end(), [=](Listener l){
         return (l.listener == listener && l.data == data);
     });
+    mRegistryListeners.erase(iter, mRegistryListeners.end());
 }
 
 uint32_t QWaylandDisplay::currentTimeMillisec()
@@ -573,14 +575,10 @@ void QWaylandDisplay::handleKeyboardFocusChanged(QWaylandInputDevice *inputDevic
     if (mLastKeyboardFocus == keyboardFocus)
         return;
 
-    if (mWaylandIntegration->mShellIntegration) {
-        mWaylandIntegration->mShellIntegration->handleKeyboardFocusChanged(keyboardFocus, mLastKeyboardFocus);
-    } else {
-        if (keyboardFocus)
-            handleWindowActivated(keyboardFocus);
-        if (mLastKeyboardFocus)
-            handleWindowDeactivated(mLastKeyboardFocus);
-    }
+    if (keyboardFocus)
+        handleWindowActivated(keyboardFocus);
+    if (mLastKeyboardFocus)
+        handleWindowDeactivated(mLastKeyboardFocus);
 
     mLastKeyboardFocus = keyboardFocus;
 }
@@ -599,6 +597,19 @@ void QWaylandDisplay::handleWaylandSync()
     QWindow *activeWindow = mActiveWindows.empty() ? nullptr : mActiveWindows.last()->window();
     if (activeWindow != QGuiApplication::focusWindow())
         QWindowSystemInterface::handleWindowActivated(activeWindow);
+
+    if (!activeWindow) {
+        if (lastInputDevice()) {
+#if QT_CONFIG(clipboard)
+            if (auto *dataDevice = lastInputDevice()->dataDevice())
+                dataDevice->invalidateSelectionOffer();
+#endif
+#if QT_CONFIG(wayland_client_primary_selection)
+            if (auto *device = lastInputDevice()->primarySelectionDevice())
+                device->invalidateSelectionOffer();
+#endif
+        }
+    }
 }
 
 const wl_callback_listener QWaylandDisplay::syncCallbackListener = {
@@ -625,6 +636,13 @@ QWaylandInputDevice *QWaylandDisplay::defaultInputDevice() const
     return mInputDevices.isEmpty() ? 0 : mInputDevices.first();
 }
 
+bool QWaylandDisplay::isKeyboardAvailable() const
+{
+    return std::any_of(
+            mInputDevices.constBegin(), mInputDevices.constEnd(),
+            [this](const QWaylandInputDevice *device) { return device->keyboard() != nullptr; });
+}
+
 #if QT_CONFIG(cursor)
 
 QWaylandCursor *QWaylandDisplay::waylandCursor()
diff --git a/src/client/qwaylanddisplay_p.h b/src/client/qwaylanddisplay_p.h
index 188e9131..09a1736a 100644
--- a/src/client/qwaylanddisplay_p.h
+++ b/src/client/qwaylanddisplay_p.h
@@ -175,8 +175,6 @@ public:
     QWaylandHardwareIntegration *hardwareIntegration() const { return mHardwareIntegration.data(); }
     QWaylandXdgOutputManagerV1 *xdgOutputManager() const { return mXdgOutputManager.data(); }
 
-    bool usingInputContextFromCompositor() const { return mUsingInputContextFromCompositor; }
-
     struct RegistryGlobal {
         uint32_t id;
         QString interface;
@@ -217,6 +215,7 @@ public:
     void destroyFrameQueue(const FrameQueue &q);
     void dispatchQueueWhile(wl_event_queue *queue, std::function<bool()> condition, int timeout = -1);
 
+    bool isKeyboardAvailable() const;
 public slots:
     void blockingReadEvents();
     void flushRequests();
@@ -282,7 +281,6 @@ private:
     QReadWriteLock m_frameQueueLock;
 
     bool mClientSideInputContextRequested = !QPlatformInputContextFactory::requested().isNull();
-    bool mUsingInputContextFromCompositor = false;
 
     void registry_global(uint32_t id, const QString &interface, uint32_t version) override;
     void registry_global_remove(uint32_t id) override;
diff --git a/src/client/qwaylandinputcontext.cpp b/src/client/qwaylandinputcontext.cpp
index e9afe05e..e290baa2 100644
--- a/src/client/qwaylandinputcontext.cpp
+++ b/src/client/qwaylandinputcontext.cpp
@@ -51,6 +51,10 @@
 #include "qwaylandinputmethodeventbuilder_p.h"
 #include "qwaylandwindow_p.h"
 
+#if QT_CONFIG(xkbcommon)
+#include <locale.h>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 Q_LOGGING_CATEGORY(qLcQpaInputMethods, "qt.qpa.input.methods")
@@ -383,8 +387,10 @@ void QWaylandTextInput::zwp_text_input_v2_input_method_changed(uint32_t serial,
 Qt::KeyboardModifiers QWaylandTextInput::modifiersToQtModifiers(uint32_t modifiers)
 {
     Qt::KeyboardModifiers ret = Qt::NoModifier;
-    for (int i = 0; modifiers >>= 1; ++i) {
-        ret |= m_modifiersMap[i];
+    for (int i = 0; i < m_modifiersMap.size(); ++i) {
+        if (modifiers & (1 << i)) {
+            ret |= m_modifiersMap[i];
+        }
     }
     return ret;
 }
@@ -406,6 +412,8 @@ bool QWaylandInputContext::isValid() const
 void QWaylandInputContext::reset()
 {
     qCDebug(qLcQpaInputMethods) << Q_FUNC_INFO;
+    if (m_composeState)
+        xkb_compose_state_reset(m_composeState);
 
     QPlatformInputContext::reset();
 
@@ -526,9 +534,14 @@ Qt::LayoutDirection QWaylandInputContext::inputDirection() const
     return textInput()->inputDirection();
 }
 
-void QWaylandInputContext::setFocusObject(QObject *)
+void QWaylandInputContext::setFocusObject(QObject *object)
 {
     qCDebug(qLcQpaInputMethods) << Q_FUNC_INFO;
+#if QT_CONFIG(xkbcommon)
+    m_focusObject = object;
+#else
+    Q_UNUSED(object);
+#endif
 
     if (!textInput())
         return;
@@ -561,6 +574,92 @@ QWaylandTextInput *QWaylandInputContext::textInput() const
     return mDisplay->defaultInputDevice()->textInput();
 }
 
+#if QT_CONFIG(xkbcommon)
+
+void QWaylandInputContext::ensureInitialized()
+{
+    if (m_initialized)
+        return;
+
+    if (!m_XkbContext) {
+        qCWarning(qLcQpaInputMethods) << "error: xkb context has not been set on" << metaObject()->className();
+        return;
+    }
+
+    m_initialized = true;
+    const char *locale = setlocale(LC_CTYPE, "");
+    if (!locale)
+        locale = setlocale(LC_CTYPE, nullptr);
+    qCDebug(qLcQpaInputMethods) << "detected locale (LC_CTYPE):" << locale;
+
+    m_composeTable = xkb_compose_table_new_from_locale(m_XkbContext, locale, XKB_COMPOSE_COMPILE_NO_FLAGS);
+    if (m_composeTable)
+        m_composeState = xkb_compose_state_new(m_composeTable, XKB_COMPOSE_STATE_NO_FLAGS);
+
+    if (!m_composeTable) {
+        qCWarning(qLcQpaInputMethods, "failed to create compose table");
+        return;
+    }
+    if (!m_composeState) {
+        qCWarning(qLcQpaInputMethods, "failed to create compose state");
+        return;
+    }
+}
+
+bool QWaylandInputContext::filterEvent(const QEvent *event)
+{
+    auto keyEvent = static_cast<const QKeyEvent *>(event);
+    if (keyEvent->type() != QEvent::KeyPress)
+        return false;
+
+    if (!inputMethodAccepted())
+        return false;
+
+    // lazy initialization - we don't want to do this on an app startup
+    ensureInitialized();
+
+    if (!m_composeTable || !m_composeState)
+        return false;
+
+    xkb_compose_state_feed(m_composeState, keyEvent->nativeVirtualKey());
+
+    switch (xkb_compose_state_get_status(m_composeState)) {
+    case XKB_COMPOSE_COMPOSING:
+        return true;
+    case XKB_COMPOSE_CANCELLED:
+        reset();
+        return false;
+    case XKB_COMPOSE_COMPOSED:
+    {
+        const int size = xkb_compose_state_get_utf8(m_composeState, nullptr, 0);
+        QVarLengthArray<char, 32> buffer(size + 1);
+        xkb_compose_state_get_utf8(m_composeState, buffer.data(), buffer.size());
+        QString composedText = QString::fromUtf8(buffer.constData());
+
+        QInputMethodEvent event;
+        event.setCommitString(composedText);
+
+        if (!m_focusObject && qApp)
+            m_focusObject = qApp->focusObject();
+
+        if (m_focusObject)
+            QCoreApplication::sendEvent(m_focusObject, &event);
+        else
+            qCWarning(qLcQpaInputMethods, "no focus object");
+
+        reset();
+        return true;
+    }
+    case XKB_COMPOSE_NOTHING:
+        return false;
+    default:
+        Q_UNREACHABLE();
+        return false;
+    }
+}
+
+#endif
+
 }
 
 QT_END_NAMESPACE
diff --git a/src/client/qwaylandinputcontext_p.h b/src/client/qwaylandinputcontext_p.h
index 10132dfe..50db6344 100644
--- a/src/client/qwaylandinputcontext_p.h
+++ b/src/client/qwaylandinputcontext_p.h
@@ -61,6 +61,10 @@
 
 #include <QtWaylandClient/private/qwayland-text-input-unstable-v2.h>
 #include <qwaylandinputmethodeventbuilder_p.h>
+#include <qtwaylandclientglobal_p.h>
+#if QT_CONFIG(xkbcommon)
+#include <xkbcommon/xkbcommon-compose.h>
+#endif
 
 struct wl_callback;
 struct wl_callback_listener;
@@ -155,11 +159,28 @@ public:
 
     void setFocusObject(QObject *object) override;
 
+#if QT_CONFIG(xkbcommon)
+    bool filterEvent(const QEvent *event) override;
+
+    // This invokable is called from QXkbCommon::setXkbContext().
+    Q_INVOKABLE void setXkbContext(struct xkb_context *context) { m_XkbContext = context; }
+#endif
+
 private:
     QWaylandTextInput *textInput() const;
 
     QWaylandDisplay *mDisplay = nullptr;
     QPointer<QWindow> mCurrentWindow;
+
+#if QT_CONFIG(xkbcommon)
+    void ensureInitialized();
+
+    bool m_initialized = false;
+    QObject *m_focusObject = nullptr;
+    xkb_compose_table *m_composeTable = nullptr;
+    xkb_compose_state *m_composeState = nullptr;
+    struct xkb_context *m_XkbContext = nullptr;
+#endif
 };
 
 }
diff --git a/src/client/qwaylandinputdevice.cpp b/src/client/qwaylandinputdevice.cpp
index ed4a0eb4..514457e9 100644
--- a/src/client/qwaylandinputdevice.cpp
+++ b/src/client/qwaylandinputdevice.cpp
@@ -1201,7 +1201,7 @@ void QWaylandInputDevice::Keyboard::handleKey(ulong timestamp, QEvent::Type type
     QPlatformInputContext *inputContext = QGuiApplicationPrivate::platformIntegration()->inputContext();
     bool filtered = false;
 
-    if (inputContext && !mParent->mQDisplay->usingInputContextFromCompositor()) {
+    if (inputContext) {
         QKeyEvent event(type, key, modifiers, nativeScanCode, nativeVirtualKey,
                         nativeModifiers, text, autorepeat, count);
         event.setTimestamp(timestamp);
@@ -1300,14 +1300,6 @@ void QWaylandInputDevice::Keyboard::handleFocusDestroyed()
 void QWaylandInputDevice::Keyboard::handleFocusLost()
 {
     mFocus = nullptr;
-#if QT_CONFIG(clipboard)
-    if (auto *dataDevice = mParent->dataDevice())
-        dataDevice->invalidateSelectionOffer();
-#endif
-#if QT_CONFIG(wayland_client_primary_selection)
-    if (auto *device = mParent->primarySelectionDevice())
-        device->invalidateSelectionOffer();
-#endif
     mParent->mQDisplay->handleKeyboardFocusChanged(mParent);
     mRepeatTimer.stop();
 }
diff --git a/src/client/qwaylandintegration.cpp b/src/client/qwaylandintegration.cpp
index 7ad8e05e..e5e7dd42 100644
--- a/src/client/qwaylandintegration.cpp
+++ b/src/client/qwaylandintegration.cpp
@@ -262,6 +262,14 @@ QWaylandDisplay *QWaylandIntegration::display() const
     return mDisplay.data();
 }
 
+Qt::KeyboardModifiers QWaylandIntegration::queryKeyboardModifiers() const
+{
+    if (auto *seat = mDisplay->currentInputDevice()) {
+        return seat->modifiers();
+    }
+    return Qt::NoModifier;
+}
+
 QList<int> QWaylandIntegration::possibleKeys(const QKeyEvent *event) const
 {
     if (auto *seat = mDisplay->currentInputDevice())
@@ -474,13 +482,11 @@ void QWaylandIntegration::reconfigureInputContext()
 
 #if QT_CONFIG(xkbcommon)
     QXkbCommon::setXkbContext(mInputContext.data(), mDisplay->xkbContext());
+    if (QWaylandInputContext* waylandInput = qobject_cast<QWaylandInputContext*>(mInputContext.get())) {
+        waylandInput->setXkbContext(mDisplay->xkbContext());
+    }
 #endif
 
-    // Even if compositor-side input context handling has been requested, we fallback to
-    // client-side handling if compositor does not provide the text-input extension. This
-    // is why we need to check here which input context actually is being used.
-    mDisplay->mUsingInputContextFromCompositor = qobject_cast<QWaylandInputContext *>(mInputContext.data());
-
     qCDebug(lcQpaWayland) << "using input method:" << inputContext()->metaObject()->className();
 }
 
diff --git a/src/client/qwaylandintegration_p.h b/src/client/qwaylandintegration_p.h
index ff70ae25..73b80658 100644
--- a/src/client/qwaylandintegration_p.h
+++ b/src/client/qwaylandintegration_p.h
@@ -107,6 +107,8 @@ public:
 
     QWaylandDisplay *display() const;
 
+    Qt::KeyboardModifiers queryKeyboardModifiers() const override;
+
     QList<int> possibleKeys(const QKeyEvent *event) const override;
 
     QStringList themeNames() const override;
diff --git a/src/client/qwaylandscreen.cpp b/src/client/qwaylandscreen.cpp
index 6cb337de..7c2d9be3 100644
--- a/src/client/qwaylandscreen.cpp
+++ b/src/client/qwaylandscreen.cpp
@@ -72,7 +72,7 @@ QWaylandScreen::QWaylandScreen(QWaylandDisplay *waylandDisplay, int version, uin
         qCWarning(lcQpaWayland) << "wl_output done event not supported by compositor,"
                                 << "QScreen may not work correctly";
         mWaylandDisplay->forceRoundTrip(); // Give the compositor a chance to send geometry etc.
-        mOutputDone = true; // Fake the done event
+        mProcessedEvents |= OutputDoneEvent; // Fake the done event
         maybeInitialize();
     }
 }
@@ -83,14 +83,25 @@ QWaylandScreen::~QWaylandScreen()
         zxdg_output_v1::destroy();
 }
 
+uint QWaylandScreen::requiredEvents() const
+{
+    uint ret = OutputDoneEvent;
+
+    if (mWaylandDisplay->xdgOutputManager()) {
+        ret |= XdgOutputNameEvent;
+
+        if (mWaylandDisplay->xdgOutputManager()->version() < 3)
+            ret |= XdgOutputDoneEvent;
+    }
+    return ret;
+}
+
 void QWaylandScreen::maybeInitialize()
 {
     Q_ASSERT(!mInitialized);
 
-    if (!mOutputDone)
-        return;
-
-    if (mWaylandDisplay->xdgOutputManager() && !mXdgOutputDone)
+    const uint requiredEvents = this->requiredEvents();
+    if ((mProcessedEvents & requiredEvents) != requiredEvents)
         return;
 
     mInitialized = true;
@@ -276,9 +287,8 @@ void QWaylandScreen::output_scale(int32_t factor)
 
 void QWaylandScreen::output_done()
 {
-    mOutputDone = true;
-    if (zxdg_output_v1::isInitialized() && mWaylandDisplay->xdgOutputManager()->version() >= 3)
-        mXdgOutputDone = true;
+    mProcessedEvents |= OutputDoneEvent;
+
     if (mInitialized) {
         updateOutputProperties();
         if (zxdg_output_v1::isInitialized())
@@ -339,7 +349,7 @@ void QWaylandScreen::zxdg_output_v1_done()
     if (Q_UNLIKELY(mWaylandDisplay->xdgOutputManager()->version() >= 3))
         qWarning(lcQpaWayland) << "zxdg_output_v1.done received on version 3 or newer, this is most likely a bug in the compositor";
 
-    mXdgOutputDone = true;
+    mProcessedEvents |= XdgOutputDoneEvent;
     if (mInitialized)
         updateXdgOutputProperties();
     else
@@ -348,7 +358,11 @@ void QWaylandScreen::zxdg_output_v1_done()
 
 void QWaylandScreen::zxdg_output_v1_name(const QString &name)
 {
+    if (Q_UNLIKELY(mInitialized))
+        qWarning(lcQpaWayland) << "zxdg_output_v1.name received after output has been initialized, this is most likely a bug in the compositor";
+
     mOutputName = name;
+    mProcessedEvents |= XdgOutputNameEvent;
 }
 
 void QWaylandScreen::updateXdgOutputProperties()
diff --git a/src/client/qwaylandscreen_p.h b/src/client/qwaylandscreen_p.h
index df1c94f2..050cfdc0 100644
--- a/src/client/qwaylandscreen_p.h
+++ b/src/client/qwaylandscreen_p.h
@@ -116,6 +116,13 @@ public:
     static QWaylandScreen *fromWlOutput(::wl_output *output);
 
 private:
+    enum Event : uint {
+        XdgOutputDoneEvent = 0x1,
+        OutputDoneEvent = 0x2,
+        XdgOutputNameEvent = 0x4,
+    };
+    uint requiredEvents() const;
+
     void output_mode(uint32_t flags, int width, int height, int refresh) override;
     void output_geometry(int32_t x, int32_t y,
                          int32_t width, int32_t height,
@@ -148,8 +155,7 @@ private:
     QSize mPhysicalSize;
     QString mOutputName;
     Qt::ScreenOrientation m_orientation = Qt::PrimaryOrientation;
-    bool mOutputDone = false;
-    bool mXdgOutputDone = false;
+    uint mProcessedEvents = 0;
     bool mInitialized = false;
 
 #if QT_CONFIG(cursor)
diff --git a/src/client/qwaylandwindow.cpp b/src/client/qwaylandwindow.cpp
index bc031ed5..ba881cb3 100644
--- a/src/client/qwaylandwindow.cpp
+++ b/src/client/qwaylandwindow.cpp
@@ -96,7 +96,6 @@ QWaylandWindow::QWaylandWindow(QWindow *window, QWaylandDisplay *display)
 QWaylandWindow::~QWaylandWindow()
 {
     mDisplay->destroyFrameQueue(mFrameQueue);
-    mDisplay->handleWindowDestroyed(this);
 
     delete mWindowDecoration;
 
@@ -194,10 +193,11 @@ void QWaylandWindow::initWindow()
     if (QScreen *s = window()->screen())
         setOrientationMask(s->orientationUpdateMask());
     setWindowFlags(window()->flags());
-    if (window()->geometry().isEmpty())
+    QRect geometry = windowGeometry();
+    if (geometry.isEmpty())
         setGeometry_helper(QRect(QPoint(), QSize(500,500)));
     else
-        setGeometry_helper(window()->geometry());
+        setGeometry_helper(geometry);
     setMask(window()->mask());
     if (mShellSurface)
         mShellSurface->requestWindowStates(window()->windowStates());
@@ -265,6 +265,8 @@ void QWaylandWindow::reset()
 
     mMask = QRegion();
     mQueuedBuffer = nullptr;
+
+    mDisplay->handleWindowDestroyed(this);
 }
 
 QWaylandWindow *QWaylandWindow::fromWlSurface(::wl_surface *surface)
@@ -332,14 +334,21 @@ void QWaylandWindow::setWindowIcon(const QIcon &icon)
 
 void QWaylandWindow::setGeometry_helper(const QRect &rect)
 {
+    QSize minimum = windowMinimumSize();
+    QSize maximum = windowMaximumSize();
     QPlatformWindow::setGeometry(QRect(rect.x(), rect.y(),
-                qBound(window()->minimumWidth(), rect.width(), window()->maximumWidth()),
-                qBound(window()->minimumHeight(), rect.height(), window()->maximumHeight())));
+                qBound(minimum.width(), rect.width(), maximum.width()),
+                qBound(minimum.height(), rect.height(), maximum.height())));
 
     if (mSubSurfaceWindow) {
         QMargins m = QPlatformWindow::parent()->frameMargins();
         mSubSurfaceWindow->set_position(rect.x() + m.left(), rect.y() + m.top());
-        mSubSurfaceWindow->parent()->window()->requestUpdate();
+
+        QWaylandWindow *parentWindow = mSubSurfaceWindow->parent();
+        if (parentWindow && parentWindow->isExposed()) {
+            QRect parentExposeGeometry(QPoint(), parentWindow->geometry().size());
+            parentWindow->sendExposeEvent(parentExposeGeometry);
+        }
     }
 }
 
@@ -362,7 +371,7 @@ void QWaylandWindow::setGeometry(const QRect &rect)
     if (isExposed() && !mInResizeFromApplyConfigure && exposeGeometry != mLastExposeGeometry)
         sendExposeEvent(exposeGeometry);
 
-    if (mShellSurface)
+    if (mShellSurface && isExposed())
         mShellSurface->setWindowGeometry(windowContentGeometry());
 
     if (isOpaque() && mMask.isEmpty())
@@ -429,7 +438,7 @@ void QWaylandWindow::setVisible(bool visible)
         initWindow();
         mDisplay->flushRequests();
 
-        setGeometry(window()->geometry());
+        setGeometry(windowGeometry());
         // Don't flush the events here, or else the newly visible window may start drawing, but since
         // there was no frame before it will be stuck at the waitForFrameSync() in
         // QWaylandShmBackingStore::beginPaint().
@@ -456,14 +465,15 @@ void QWaylandWindow::lower()
 
 void QWaylandWindow::setMask(const QRegion &mask)
 {
+    QReadLocker locker(&mSurfaceLock);
+    if (!mSurface)
+        return;
+
     if (mMask == mask)
         return;
 
     mMask = mask;
 
-    if (!mSurface)
-        return;
-
     if (mMask.isEmpty()) {
         mSurface->set_input_region(nullptr);
 
@@ -613,9 +623,13 @@ void QWaylandWindow::commit()
 
 const wl_callback_listener QWaylandWindow::callbackListener = {
     [](void *data, wl_callback *callback, uint32_t time) {
-        Q_UNUSED(callback);
         Q_UNUSED(time);
         auto *window = static_cast<QWaylandWindow*>(data);
+
+        Q_ASSERT(callback == window->mFrameCallback);
+        wl_callback_destroy(callback);
+        window->mFrameCallback = nullptr;
+
         window->handleFrameCallback();
     }
 };
@@ -1070,10 +1084,18 @@ bool QWaylandWindow::setMouseGrabEnabled(bool grab)
     return true;
 }
 
+Qt::WindowStates QWaylandWindow::windowStates() const
+{
+    return mLastReportedWindowStates;
+}
+
 void QWaylandWindow::handleWindowStatesChanged(Qt::WindowStates states)
 {
     createDecoration();
-    QWindowSystemInterface::handleWindowStateChanged(window(), states, mLastReportedWindowStates);
+    Qt::WindowStates statesWithoutActive = states & ~Qt::WindowActive;
+    Qt::WindowStates lastStatesWithoutActive = mLastReportedWindowStates & ~Qt::WindowActive;
+    QWindowSystemInterface::handleWindowStateChanged(window(), statesWithoutActive,
+                                                     lastStatesWithoutActive);
     mLastReportedWindowStates = states;
 }
 
@@ -1161,16 +1183,15 @@ void QWaylandWindow::requestUpdate()
 void QWaylandWindow::handleUpdate()
 {
     qCDebug(lcWaylandBackingstore) << "handleUpdate" << QThread::currentThread();
+
+    if (mWaitingForFrameCallback)
+        return;
+
     // TODO: Should sync subsurfaces avoid requesting frame callbacks?
     QReadLocker lock(&mSurfaceLock);
     if (!mSurface)
         return;
 
-    if (mFrameCallback) {
-        wl_callback_destroy(mFrameCallback);
-        mFrameCallback = nullptr;
-    }
-
     QMutexLocker locker(mFrameQueue.mutex);
     struct ::wl_surface *wrappedSurface = reinterpret_cast<struct ::wl_surface *>(wl_proxy_create_wrapper(mSurface->object()));
     wl_proxy_set_queue(reinterpret_cast<wl_proxy *>(wrappedSurface), mFrameQueue.queue);
@@ -1231,12 +1252,14 @@ bool QWaylandWindow::isOpaque() const
 
 void QWaylandWindow::setOpaqueArea(const QRegion &opaqueArea)
 {
-    if (opaqueArea == mOpaqueArea || !mSurface)
+    const QRegion translatedOpaqueArea = opaqueArea.translated(frameMargins().left(), frameMargins().top());
+
+    if (translatedOpaqueArea == mOpaqueArea || !mSurface)
         return;
 
-    mOpaqueArea = opaqueArea;
+    mOpaqueArea = translatedOpaqueArea;
 
-    struct ::wl_region *region = mDisplay->createRegion(opaqueArea);
+    struct ::wl_region *region = mDisplay->createRegion(translatedOpaqueArea);
     mSurface->set_opaque_region(region);
     wl_region_destroy(region);
 }
diff --git a/src/client/qwaylandwindow_p.h b/src/client/qwaylandwindow_p.h
index 6cc1664b..e0687962 100644
--- a/src/client/qwaylandwindow_p.h
+++ b/src/client/qwaylandwindow_p.h
@@ -148,6 +148,7 @@ public:
     void setWindowState(Qt::WindowStates states) override;
     void setWindowFlags(Qt::WindowFlags flags) override;
     void handleWindowStatesChanged(Qt::WindowStates states);
+    Qt::WindowStates windowStates() const;
 
     void raise() override;
     void lower() override;
diff --git a/src/client/shellintegration/qwaylandshellintegration_p.h b/src/client/shellintegration/qwaylandshellintegration_p.h
index ccad0048..4cc9b3b8 100644
--- a/src/client/shellintegration/qwaylandshellintegration_p.h
+++ b/src/client/shellintegration/qwaylandshellintegration_p.h
@@ -73,11 +73,10 @@ public:
         return true;
     }
     virtual QWaylandShellSurface *createShellSurface(QWaylandWindow *window) = 0;
+    // kept for binary compat with layer-shell-qt
     virtual void handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus) {
-        if (newFocus)
-            m_display->handleWindowActivated(newFocus);
-        if (oldFocus)
-            m_display->handleWindowDeactivated(oldFocus);
+        Q_UNUSED(newFocus);
+        Q_UNUSED(oldFocus);
     }
     virtual void *nativeResourceForWindow(const QByteArray &resource, QWindow *window) {
         Q_UNUSED(resource);
diff --git a/src/compositor/compositor_api/qwaylandquickcompositor.cpp b/src/compositor/compositor_api/qwaylandquickcompositor.cpp
index 49f0860e..db1cf00f 100644
--- a/src/compositor/compositor_api/qwaylandquickcompositor.cpp
+++ b/src/compositor/compositor_api/qwaylandquickcompositor.cpp
@@ -161,7 +161,7 @@ void QWaylandQuickCompositor::grabSurface(QWaylandSurfaceGrabber *grabber, const
     GrabState *state = new GrabState;
     state->grabber = grabber;
     state->buffer = buffer;
-    static_cast<QQuickWindow *>(output->window())->scheduleRenderJob(state, QQuickWindow::NoStage);
+    static_cast<QQuickWindow *>(output->window())->scheduleRenderJob(state, QQuickWindow::AfterRenderingStage);
 #else
     emit grabber->failed(QWaylandSurfaceGrabber::UnknownBufferType);
 #endif
diff --git a/src/compositor/compositor_api/qwaylandquickitem.cpp b/src/compositor/compositor_api/qwaylandquickitem.cpp
index 15f0195c..2218f43a 100644
--- a/src/compositor/compositor_api/qwaylandquickitem.cpp
+++ b/src/compositor/compositor_api/qwaylandquickitem.cpp
@@ -737,6 +737,7 @@ void QWaylandQuickItem::handleSubsurfaceAdded(QWaylandSurface *childSurface)
         childItem->setVisible(true);
         childItem->setParentItem(this);
         connect(childSurface, &QWaylandSurface::subsurfacePositionChanged, childItem, &QWaylandQuickItem::handleSubsurfacePosition);
+        connect(childSurface, &QWaylandSurface::destroyed, childItem, &QObject::deleteLater);
     } else {
         bool success = QMetaObject::invokeMethod(d->subsurfaceHandler, "handleSubsurfaceAdded", Q_ARG(QWaylandSurface *, childSurface));
         if (!success)
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.cpp b/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.cpp
index 7889f575..201b583b 100644
--- a/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.cpp
+++ b/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.cpp
@@ -131,14 +131,16 @@ void QWaylandEglWindow::updateSurface(bool create)
             if (!disableResizeCheck) {
                 wl_egl_window_get_attached_size(m_waylandEglWindow, &current_width, &current_height);
             }
-            if (disableResizeCheck || (current_width != sizeWithMargins.width() || current_height != sizeWithMargins.height())) {
+            if (disableResizeCheck || (current_width != sizeWithMargins.width() || current_height != sizeWithMargins.height()) || m_requestedSize != sizeWithMargins) {
                 wl_egl_window_resize(m_waylandEglWindow, sizeWithMargins.width(), sizeWithMargins.height(), mOffset.x(), mOffset.y());
+                m_requestedSize = sizeWithMargins;
                 mOffset = QPoint();
 
                 m_resize = true;
             }
         } else if (create && wlSurface()) {
             m_waylandEglWindow = wl_egl_window_create(wlSurface(), sizeWithMargins.width(), sizeWithMargins.height());
+            m_requestedSize = sizeWithMargins;
         }
 
         if (!m_eglSurface && m_waylandEglWindow && create) {
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h b/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h
index 5b1f4d56..0079dfef 100644
--- a/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h
+++ b/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h
@@ -88,6 +88,7 @@ private:
     mutable QOpenGLFramebufferObject *m_contentFBO = nullptr;
 
     QSurfaceFormat m_format;
+    QSize m_requestedSize;
 };
 
 }
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
index ccebf43d..683fe123 100644
--- a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
+++ b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
@@ -336,6 +336,8 @@ QWaylandGLContext::QWaylandGLContext(EGLDisplay eglDisplay, QWaylandDisplay *dis
                                << "It may also cause the event loop to freeze in some situations";
     }
 
+    m_supportSurfaceLessContext = q_hasEglExtension(m_eglDisplay, "EGL_KHR_surfaceless_context");
+
     updateGLFormat();
 }
 
@@ -404,7 +406,10 @@ void QWaylandGLContext::updateGLFormat()
 QWaylandGLContext::~QWaylandGLContext()
 {
     delete m_blitter;
+    m_blitter = nullptr;
     eglDestroyContext(m_eglDisplay, m_context);
+    if (m_decorationsContext != EGL_NO_CONTEXT)
+        eglDestroyContext(m_eglDisplay, m_decorationsContext);
 }
 
 bool QWaylandGLContext::makeCurrent(QPlatformSurface *surface)
@@ -439,6 +444,10 @@ bool QWaylandGLContext::makeCurrent(QPlatformSurface *surface)
         eglSurface = window->eglSurface();
     }
 
+    if (eglSurface == EGL_NO_SURFACE && m_supportSurfaceLessContext) {
+        return false;
+    }
+
     if (!eglMakeCurrent(m_eglDisplay, eglSurface, eglSurface, m_context)) {
         qWarning("QWaylandGLContext::makeCurrent: eglError: %x, this: %p \n", eglGetError(), this);
         window->setCanResize(true);
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h
index 46c7bb76..93edaec0 100644
--- a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h
+++ b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h
@@ -93,6 +93,7 @@ private:
     DecorationsBlitter *m_blitter = nullptr;
     uint m_api;
     bool m_supportNonBlockingSwap = true;
+    bool m_supportSurfaceLessContext = false;
 };
 
 }
diff --git a/src/plugins/shellintegration/wl-shell/qwaylandwlshellsurface.cpp b/src/plugins/shellintegration/wl-shell/qwaylandwlshellsurface.cpp
index 245fec19..8f41118d 100644
--- a/src/plugins/shellintegration/wl-shell/qwaylandwlshellsurface.cpp
+++ b/src/plugins/shellintegration/wl-shell/qwaylandwlshellsurface.cpp
@@ -134,7 +134,7 @@ void QWaylandWlShellSurface::applyConfigure()
 {
     if ((m_pending.states & (Qt::WindowMaximized|Qt::WindowFullScreen))
             && !(m_applied.states & (Qt::WindowMaximized|Qt::WindowFullScreen))) {
-        m_normalSize = m_window->window()->frameGeometry().size();
+        m_normalSize = m_window->windowFrameGeometry().size();
     }
 
     if (m_pending.states != m_applied.states)
diff --git a/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration.cpp b/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration.cpp
index 4e25949f..cfc60939 100644
--- a/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration.cpp
+++ b/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration.cpp
@@ -85,13 +85,6 @@ QWaylandShellSurface *QWaylandXdgShellV5Integration::createShellSurface(QWayland
     return m_xdgShell->createXdgSurface(window);
 }
 
-void QWaylandXdgShellV5Integration::handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus) {
-    if (newFocus && qobject_cast<QWaylandXdgPopupV5 *>(newFocus->shellSurface()))
-        m_display->handleWindowActivated(newFocus);
-    if (oldFocus && qobject_cast<QWaylandXdgPopupV5 *>(oldFocus->shellSurface()))
-        m_display->handleWindowDeactivated(oldFocus);
-}
-
 }
 
 QT_END_NAMESPACE
diff --git a/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration_p.h b/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration_p.h
index ce6bdb9e..aed88670 100644
--- a/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration_p.h
+++ b/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgshellv5integration_p.h
@@ -67,7 +67,6 @@ public:
     QWaylandXdgShellV5Integration() {}
     bool initialize(QWaylandDisplay *display) override;
     QWaylandShellSurface *createShellSurface(QWaylandWindow *window) override;
-    void handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus) override;
 
 private:
     QScopedPointer<QWaylandXdgShellV5> m_xdgShell;
diff --git a/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgsurfacev5.cpp b/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgsurfacev5.cpp
index 770fad7e..73aba1ee 100644
--- a/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgsurfacev5.cpp
+++ b/src/plugins/shellintegration/xdg-shell-v5/qwaylandxdgsurfacev5.cpp
@@ -157,7 +157,7 @@ void QWaylandXdgSurfaceV5::applyConfigure()
     if (m_pending.isResizing)
         m_normalSize = m_pending.size;
     else if (!(m_acked.states & (Qt::WindowMaximized|Qt::WindowFullScreen)))
-        m_normalSize = m_window->window()->frameGeometry().size();
+        m_normalSize = m_window->windowFrameGeometry().size();
 
     if ((m_pending.states & Qt::WindowActive) && !(m_acked.states & Qt::WindowActive))
         m_window->display()->handleWindowActivated(m_window);
diff --git a/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6.cpp b/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6.cpp
index c137b308..8c371661 100644
--- a/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6.cpp
+++ b/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6.cpp
@@ -72,7 +72,7 @@ QWaylandXdgSurfaceV6::Toplevel::~Toplevel()
 void QWaylandXdgSurfaceV6::Toplevel::applyConfigure()
 {
     if (!(m_applied.states & (Qt::WindowMaximized|Qt::WindowFullScreen)))
-        m_normalSize = m_xdgSurface->m_window->window()->frameGeometry().size();
+        m_normalSize = m_xdgSurface->m_window->windowFrameGeometry().size();
 
     if ((m_pending.states & Qt::WindowActive) && !(m_applied.states & Qt::WindowActive))
         m_xdgSurface->m_window->display()->handleWindowActivated(m_xdgSurface->m_window);
diff --git a/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration.cpp b/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration.cpp
index 03164316..e8da8ba1 100644
--- a/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration.cpp
+++ b/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration.cpp
@@ -68,20 +68,6 @@ QWaylandShellSurface *QWaylandXdgShellV6Integration::createShellSurface(QWayland
     return m_xdgShell->getXdgSurface(window);
 }
 
-void QWaylandXdgShellV6Integration::handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus)
-{
-    if (newFocus) {
-        auto *xdgSurface = qobject_cast<QWaylandXdgSurfaceV6 *>(newFocus->shellSurface());
-        if (xdgSurface && !xdgSurface->handlesActiveState())
-            m_display->handleWindowActivated(newFocus);
-    }
-    if (oldFocus && qobject_cast<QWaylandXdgSurfaceV6 *>(oldFocus->shellSurface())) {
-        auto *xdgSurface = qobject_cast<QWaylandXdgSurfaceV6 *>(oldFocus->shellSurface());
-        if (xdgSurface && !xdgSurface->handlesActiveState())
-            m_display->handleWindowDeactivated(oldFocus);
-    }
-}
-
 }
 
 QT_END_NAMESPACE
diff --git a/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration_p.h b/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration_p.h
index 261f8cbb..c1bcd5c6 100644
--- a/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration_p.h
+++ b/src/plugins/shellintegration/xdg-shell-v6/qwaylandxdgshellv6integration_p.h
@@ -65,7 +65,6 @@ public:
     QWaylandXdgShellV6Integration() {}
     bool initialize(QWaylandDisplay *display) override;
     QWaylandShellSurface *createShellSurface(QWaylandWindow *window) override;
-    void handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus) override;
 
 private:
     QScopedPointer<QWaylandXdgShellV6> m_xdgShell;
diff --git a/src/plugins/shellintegration/xdg-shell/qwaylandxdgshell.cpp b/src/plugins/shellintegration/xdg-shell/qwaylandxdgshell.cpp
index b6d23ac1..d7d0ddf7 100644
--- a/src/plugins/shellintegration/xdg-shell/qwaylandxdgshell.cpp
+++ b/src/plugins/shellintegration/xdg-shell/qwaylandxdgshell.cpp
@@ -67,11 +67,6 @@ QWaylandXdgSurface::Toplevel::Toplevel(QWaylandXdgSurface *xdgSurface)
 
 QWaylandXdgSurface::Toplevel::~Toplevel()
 {
-    if (m_applied.states & Qt::WindowActive) {
-        QWaylandWindow *window = m_xdgSurface->window();
-        window->display()->handleWindowDeactivated(window);
-    }
-
     // The protocol spec requires that the decoration object is deleted before xdg_toplevel.
     delete m_decoration;
     m_decoration = nullptr;
@@ -83,18 +78,17 @@ QWaylandXdgSurface::Toplevel::~Toplevel()
 void QWaylandXdgSurface::Toplevel::applyConfigure()
 {
     if (!(m_applied.states & (Qt::WindowMaximized|Qt::WindowFullScreen)))
-        m_normalSize = m_xdgSurface->m_window->window()->frameGeometry().size();
+        m_normalSize = m_xdgSurface->m_window->windowFrameGeometry().size();
 
-    if ((m_pending.states & Qt::WindowActive) && !(m_applied.states & Qt::WindowActive))
+    if ((m_pending.states & Qt::WindowActive) && !(m_applied.states & Qt::WindowActive)
+        && !m_xdgSurface->m_window->display()->isKeyboardAvailable())
         m_xdgSurface->m_window->display()->handleWindowActivated(m_xdgSurface->m_window);
 
-    if (!(m_pending.states & Qt::WindowActive) && (m_applied.states & Qt::WindowActive))
+    if (!(m_pending.states & Qt::WindowActive) && (m_applied.states & Qt::WindowActive)
+        && !m_xdgSurface->m_window->display()->isKeyboardAvailable())
         m_xdgSurface->m_window->display()->handleWindowDeactivated(m_xdgSurface->m_window);
 
-    // TODO: none of the other plugins send WindowActive either, but is it on purpose?
-    Qt::WindowStates statesWithoutActive = m_pending.states & ~Qt::WindowActive;
-
-    m_xdgSurface->m_window->handleWindowStatesChanged(statesWithoutActive);
+    m_xdgSurface->m_window->handleWindowStatesChanged(m_pending.states);
 
     if (m_pending.size.isEmpty()) {
         // An empty size in the configure means it's up to the client to choose the size
@@ -105,8 +99,6 @@ void QWaylandXdgSurface::Toplevel::applyConfigure()
         m_xdgSurface->m_window->resizeFromApplyConfigure(m_pending.size);
     }
 
-    m_xdgSurface->setSizeHints();
-
     m_applied = m_pending;
     qCDebug(lcQpaWayland) << "Applied pending xdg_toplevel configure event:" << m_applied.size << m_applied.states;
 }
@@ -178,9 +170,12 @@ void QWaylandXdgSurface::Toplevel::requestWindowStates(Qt::WindowStates states)
     }
 
     if (changedStates & Qt::WindowFullScreen) {
-        if (states & Qt::WindowFullScreen)
-            set_fullscreen(nullptr);
-        else
+        if (states & Qt::WindowFullScreen) {
+            auto screen = m_xdgSurface->window()->waylandScreen();
+            if (screen) {
+                set_fullscreen(screen->output());
+            }
+        } else
             unset_fullscreen();
     }
 
@@ -254,6 +249,7 @@ QWaylandXdgSurface::QWaylandXdgSurface(QWaylandXdgShell *shell, ::xdg_surface *s
                 m_toplevel->set_parent(parentXdgSurface->m_toplevel->object());
         }
     }
+    setSizeHints();
 }
 
 QWaylandXdgSurface::~QWaylandXdgSurface()
diff --git a/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration.cpp b/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration.cpp
index 8769d971..da0dd6a7 100644
--- a/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration.cpp
+++ b/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration.cpp
@@ -69,20 +69,6 @@ QWaylandShellSurface *QWaylandXdgShellIntegration::createShellSurface(QWaylandWi
     return m_xdgShell->getXdgSurface(window);
 }
 
-void QWaylandXdgShellIntegration::handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus)
-{
-    if (newFocus) {
-        auto *xdgSurface = qobject_cast<QWaylandXdgSurface *>(newFocus->shellSurface());
-        if (xdgSurface && !xdgSurface->handlesActiveState())
-            m_display->handleWindowActivated(newFocus);
-    }
-    if (oldFocus && qobject_cast<QWaylandXdgSurface *>(oldFocus->shellSurface())) {
-        auto *xdgSurface = qobject_cast<QWaylandXdgSurface *>(oldFocus->shellSurface());
-        if (xdgSurface && !xdgSurface->handlesActiveState())
-            m_display->handleWindowDeactivated(oldFocus);
-    }
-}
-
 }
 
 QT_END_NAMESPACE
diff --git a/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration_p.h b/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration_p.h
index b6caa6c9..2f929f98 100644
--- a/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration_p.h
+++ b/src/plugins/shellintegration/xdg-shell/qwaylandxdgshellintegration_p.h
@@ -65,7 +65,6 @@ public:
     QWaylandXdgShellIntegration() {}
     bool initialize(QWaylandDisplay *display) override;
     QWaylandShellSurface *createShellSurface(QWaylandWindow *window) override;
-    void handleKeyboardFocusChanged(QWaylandWindow *newFocus, QWaylandWindow *oldFocus) override;
 
 private:
     QScopedPointer<QWaylandXdgShell> m_xdgShell;
diff --git a/src/qtwaylandscanner/qtwaylandscanner.cpp b/src/qtwaylandscanner/qtwaylandscanner.cpp
index 1d635f06..e2f87bbd 100644
--- a/src/qtwaylandscanner/qtwaylandscanner.cpp
+++ b/src/qtwaylandscanner/qtwaylandscanner.cpp
@@ -814,7 +814,9 @@ bool Scanner::process()
             printf("        if (Q_LIKELY(that)) {\n");
             printf("            that->m_resource_map.remove(resource->client(), resource);\n");
             printf("            that->%s_destroy_resource(resource);\n", interfaceNameStripped);
-            printf("            if (that->m_resource == resource)\n");
+            printf("\n");
+            printf("            that = resource->%s_object;\n", interfaceNameStripped);
+            printf("            if (that && that->m_resource == resource)\n");
             printf("                that->m_resource = nullptr;\n");
             printf("        }\n");
             printf("        delete resource;\n");
diff --git a/src/shared/qwaylandinputmethodeventbuilder.cpp b/src/shared/qwaylandinputmethodeventbuilder.cpp
index 526d0ef4..25be2509 100644
--- a/src/shared/qwaylandinputmethodeventbuilder.cpp
+++ b/src/shared/qwaylandinputmethodeventbuilder.cpp
@@ -151,7 +151,7 @@ QInputMethodEvent QWaylandInputMethodEventBuilder::buildPreedit(const QString &t
 {
     QList<QInputMethodEvent::Attribute> attributes;
 
-    if (m_preeditCursor < 0) {
+    if (m_preeditCursor <= 0) {
         attributes.append(QInputMethodEvent::Attribute(QInputMethodEvent::Cursor, 0, 0, QVariant()));
     } else if (m_preeditCursor > 0) {
         attributes.append(QInputMethodEvent::Attribute(QInputMethodEvent::Cursor, indexFromWayland(text, m_preeditCursor), 1, QVariant()));
diff --git a/src/shared/qwaylandmimehelper.cpp b/src/shared/qwaylandmimehelper.cpp
index a5fdd34d..051a91dc 100644
--- a/src/shared/qwaylandmimehelper.cpp
+++ b/src/shared/qwaylandmimehelper.cpp
@@ -60,7 +60,7 @@ QByteArray QWaylandMimeHelper::getByteArray(QMimeData *mimeData, const QString &
             buf.open(QIODevice::ReadWrite);
             QByteArray fmt = "BMP";
             if (mimeType.startsWith(QLatin1String("image/"))) {
-                QByteArray imgFmt = mimeType.mid(6).toUpper().toLatin1();
+                QByteArray imgFmt = mimeType.mid(6).toLower().toLatin1();
                 if (QImageWriter::supportedImageFormats().contains(imgFmt))
                     fmt = imgFmt;
             }
diff --git a/tests/auto/client/surface/tst_surface.cpp b/tests/auto/client/surface/tst_surface.cpp
index b8a65f15..95e4e609 100644
--- a/tests/auto/client/surface/tst_surface.cpp
+++ b/tests/auto/client/surface/tst_surface.cpp
@@ -167,17 +167,40 @@ void tst_surface::negotiateShmFormat()
 void tst_surface::createSubsurface()
 {
     QRasterWindow window;
-    window.resize(64, 64);
-    window.show();
-    QCOMPOSITOR_TRY_VERIFY(xdgToplevel());
-    exec([=] { xdgToplevel()->sendCompleteConfigure(); });
-    QCOMPOSITOR_TRY_VERIFY(xdgSurface()->m_committedConfigureSerial);
+    window.setObjectName("main");
+    window.resize(200, 200);
 
     QRasterWindow subWindow;
+    subWindow.setObjectName("subwindow");
     subWindow.setParent(&window);
     subWindow.resize(64, 64);
+
+    window.show();
     subWindow.show();
+
     QCOMPOSITOR_TRY_VERIFY(subSurface());
+    QCOMPOSITOR_TRY_VERIFY(xdgToplevel());
+    exec([=] { xdgToplevel()->sendCompleteConfigure(); });
+    QCOMPOSITOR_TRY_VERIFY(xdgSurface()->m_committedConfigureSerial);
+
+    const Surface *mainSurface = exec([=] {return surface(0);});
+    const Surface *childSurface = exec([=] {return surface(1);});
+    QSignalSpy  mainSurfaceCommitSpy(mainSurface, &Surface::commit);
+    QSignalSpy childSurfaceCommitSpy(childSurface, &Surface::commit);
+
+    // Move subsurface. The parent should redraw and commit
+    subWindow.setGeometry(100, 100, 64, 64);
+    // the toplevel should commit to indicate the subsurface moved
+    QCOMPOSITOR_TRY_COMPARE(mainSurfaceCommitSpy.count(), 1);
+    mainSurfaceCommitSpy.clear();
+    childSurfaceCommitSpy.clear();
+
+    // Move and resize the subSurface. The parent should redraw and commit
+    // The child should also redraw
+    subWindow.setGeometry(50, 50, 80, 80);
+    QCOMPOSITOR_TRY_COMPARE(mainSurfaceCommitSpy.count(), 1);
+    QCOMPOSITOR_TRY_COMPARE(childSurfaceCommitSpy.count(), 1);
+
 }
 
 // Used to cause a crash in libwayland (QTBUG-79674)
diff --git a/tests/auto/client/xdgshell/tst_xdgshell.cpp b/tests/auto/client/xdgshell/tst_xdgshell.cpp
index 2277bbb8..73d1eb9c 100644
--- a/tests/auto/client/xdgshell/tst_xdgshell.cpp
+++ b/tests/auto/client/xdgshell/tst_xdgshell.cpp
@@ -31,6 +31,7 @@
 #include <QtGui/QOpenGLWindow>
 #include <QtGui/qpa/qplatformnativeinterface.h>
 #include <QtWaylandClient/private/wayland-wayland-client-protocol.h>
+#include <QtWaylandClient/private/qwaylandwindow_p.h>
 
 using namespace MockCompositor;
 
@@ -138,6 +139,7 @@ void tst_xdgshell::configureSize()
 
 void tst_xdgshell::configureStates()
 {
+    QVERIFY(qputenv("QT_WAYLAND_FRAME_CALLBACK_TIMEOUT", "0"));
     QRasterWindow window;
     window.resize(64, 48);
     window.show();
@@ -154,9 +156,12 @@ void tst_xdgshell::configureStates()
     // Toplevel windows don't know their position on xdg-shell
 //    QCOMPARE(window.frameGeometry().topLeft(), QPoint()); // TODO: this doesn't currently work when window decorations are enabled
 
-//    QEXPECT_FAIL("", "configure has already been acked, we shouldn't have to wait for isActive", Continue);
-//    QVERIFY(window.isActive());
-    QTRY_VERIFY(window.isActive()); // Just make sure it eventually get's set correctly
+    // window.windowstate() is driven by keyboard focus, however for decorations we want to follow
+    // XDGShell this is internal to QtWayland so it is queried directly
+    auto waylandWindow = static_cast<QtWaylandClient::QWaylandWindow *>(window.handle());
+    Q_ASSERT(waylandWindow);
+    QTRY_VERIFY(waylandWindow->windowStates().testFlag(
+            Qt::WindowActive)); // Just make sure it eventually get's set correctly
 
     const QSize screenSize(640, 480);
     const uint maximizedSerial = exec([=] {
@@ -186,6 +191,7 @@ void tst_xdgshell::configureStates()
     QCOMPARE(window.windowStates(), Qt::WindowNoState);
     QCOMPARE(window.frameGeometry().size(), windowedSize);
 //    QCOMPARE(window.frameGeometry().topLeft(), QPoint()); // TODO: this doesn't currently work when window decorations are enabled
+    QVERIFY(qunsetenv("QT_WAYLAND_FRAME_CALLBACK_TIMEOUT"));
 }
 
 void tst_xdgshell::popup()
@@ -505,7 +511,7 @@ void tst_xdgshell::minMaxSize()
     window.show();
     QCOMPOSITOR_TRY_VERIFY(xdgToplevel());
 
-    exec([=] { xdgToplevel()->sendCompleteConfigure(); });
+    // we don't roundtrip with our configuration the initial commit should be correct
 
     QCOMPOSITOR_TRY_COMPARE(xdgToplevel()->m_committed.minSize, QSize(100, 100));
     QCOMPOSITOR_TRY_COMPARE(xdgToplevel()->m_committed.maxSize, QSize(1000, 1000));
