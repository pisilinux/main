diff -Naur Ri-li-2.0.1.orig/src/audio.cc Ri-li-2.0.1/src/audio.cc
--- Ri-li-2.0.1.orig/src/audio.cc	2007-11-02 13:48:15.000000000 +0200
+++ Ri-li-2.0.1/src/audio.cc	2008-05-11 10:00:23.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Audio
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,9 +21,12 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
+#include <iostream>
+using namespace std;
+
 #include <stdlib.h>
-#include <iostream.h>
 #include <string.h>
+#include <iterator>
 
 #include "audio.h"
 #include "utils.h"
@@ -61,7 +64,7 @@
     return false;
   }
   
-  /*** Allocation de la mémoire ***/
+  /*** Allocation de la mï¿½moire ***/
   N=sFin;
   Son=new Mix_Chunk* [sFin];
   
@@ -139,7 +142,7 @@
   PlayMusic();
 }
 
-/*** Passe à la music de jeu suivante ***/
+/*** Passe ï¿½ la music de jeu suivante ***/
 /****************************************/
 void Audio::NextMusic(void)
 {
diff -Naur Ri-li-2.0.1.orig/src/audio.cc~ Ri-li-2.0.1/src/audio.cc~
--- Ri-li-2.0.1.orig/src/audio.cc~	1970-01-01 02:00:00.000000000 +0200
+++ Ri-li-2.0.1/src/audio.cc~	2008-05-11 09:58:13.000000000 +0300
@@ -0,0 +1,204 @@
+//      (_||_/
+//      (    )       Classe Audio
+//     ( o  0 )
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
+//                   Copyright (C) 2006 By Dominique Roux-Serret
+// .OOOo      oOOO.  roux-serret@ifrance.com
+//-(   )------(   )---------------------------------------
+//  ( (        ) /   Le 27/05/2006
+//   (_)      (_/
+
+//    This program is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 or version 3 of the License.
+
+//    This program is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+
+//    You should have received a copy of the GNU General Public License along
+//    with this program; if not, write to the Free Software Foundation, Inc.,
+//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#include <iostream>
+using std::cerr;
+using std::endl;
+            
+#include <stdlib.h>
+#include <string.h>
+#include <iterator>
+
+#include "audio.h"
+#include "utils.h"
+#include "preference.h"
+
+/*** Variable globales ***/
+/*************************/
+extern sPreference Pref;
+extern int Horloge;
+
+/*** Constructeur et Destructeur ***/
+/***********************************/
+Audio::Audio(void) : N(0), NMus(0), MemoHorloge(0), Son(NULL), Music(NULL)
+{ }
+
+Audio::~Audio(void)
+{
+  if(N) {
+    Mix_HaltChannel(-1);
+    for(int i=0;i<N;i++) 
+      if(Son[i]) Mix_FreeChunk(Son[i]);
+    delete [] Son;
+  }
+  Mix_CloseAudio();
+}
+
+/*** Initialise l'Audio ***/
+/**************************/
+bool Audio::Init(void)
+{
+  char PathFile[512];
+
+  if(Mix_OpenAudio(22050,AUDIO_S16,1,1024)) {
+    cerr <<"Enable to init Sound card ! "<<SDL_GetError()<<endl;
+    return false;
+  }
+  
+  /*** Allocation de la mï¿½moire ***/
+  N=sFin;
+  Son=new Mix_Chunk* [sFin];
+  
+  /*** Chargement des sons ***/
+  strcpy(PathFile,"Sounds/clic.wav");
+  GetPath(PathFile);
+  Son[sClic]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/speed.wav");
+  GetPath(PathFile);
+  Son[sSpeed]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/crash.wav");
+  GetPath(PathFile);
+  Son[sCrash]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/end.wav");
+  GetPath(PathFile);
+  Son[sEnd]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/lose.wav");
+  GetPath(PathFile);
+  Son[sLose]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/etire.wav");
+  GetPath(PathFile);
+  Son[sEtire]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/wagon.wav");
+  GetPath(PathFile);
+  Son[sWagon]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/reduit.wav");
+  GetPath(PathFile);
+  Son[sReduit]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/live.wav");
+  GetPath(PathFile);
+  Son[sLive]=Mix_LoadWAV(PathFile);
+
+  strcpy(PathFile,"Sounds/menu.mod");
+  GetPath(PathFile);
+  Music=Mix_LoadMUS(PathFile);
+    
+  return true;
+}
+
+/*** Charge une music 0=menu 1,2,3,4 = game ***/
+/**********************************************/
+void Audio::LoadMusic(int Num)
+{
+  char Provi[512]="Sounds/jeu1.xm";
+
+  if(!N) return;
+
+  NMus=Num;
+
+  if(Music) {
+    PauseMusic(true);
+    Mix_HaltMusic(); // Arrete la music
+    Mix_FreeMusic(Music);
+    Music=NULL;
+  }
+
+  if(Num==0) { // Si music du menu
+    strcpy(Provi,"Sounds/menu.mod");
+    GetPath(Provi);
+    Music=Mix_LoadMUS(Provi);
+  }
+  else {
+    Provi[10]=(char)(Num)+'0';
+    GetPath(Provi);
+    Music=Mix_LoadMUS(Provi);
+  }
+  PlayMusic();
+}
+
+/*** Passe ï¿½ la music de jeu suivante ***/
+/****************************************/
+void Audio::NextMusic(void)
+{
+  NMus++;
+  if(NMus>2) NMus=1;
+  LoadMusic(NMus);
+}
+
+/*** Fait la lecture d'un son ***/
+/********************************/
+void Audio::Play(eSon So) {
+  if(!N) return;
+
+  if(So==sClic) {
+    if(Horloge-MemoHorloge<=120) return;
+    MemoHorloge=Horloge;
+  }
+  
+  Mix_PlayChannel(-1,Son[So],0);
+}
+
+/*** Joue la music ***/
+/*********************/
+void Audio::PlayMusic(void) {
+  if(Music && N) {
+    Mix_PlayMusic(Music,-1);
+    DoVolume();
+  }
+}
+
+/*** Met ou non en pause ***/
+/***************************/
+void Audio::Pause(bool Et)
+{
+  if(!N) return;
+
+  if(Et) SDL_PauseAudio(1);
+  else SDL_PauseAudio(0);
+}
+
+void Audio::PauseMusic(bool Et)
+{
+  if(!N) return;
+
+  if(Et) Mix_PauseMusic();
+  else Mix_ResumeMusic();
+}
+
+/*** Valide les Volumes ***/
+/**************************/
+void Audio::DoVolume(void)
+{
+  if(!N) return;
+
+  Mix_Volume(-1,(int)Pref.Volume);
+  if(NMus) Mix_VolumeMusic((int)Pref.VolumeM);
+  else Mix_VolumeMusic((int)Pref.VolumeM/2);
+}
diff -Naur Ri-li-2.0.1.orig/src/ecran.cc Ri-li-2.0.1/src/ecran.cc
--- Ri-li-2.0.1.orig/src/ecran.cc	2007-11-02 13:48:16.000000000 +0200
+++ Ri-li-2.0.1/src/ecran.cc	2008-05-11 09:49:48.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Ecran
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,7 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
@@ -91,13 +91,13 @@
 {
   int x,y;
 
-  if(NScore!=Score) { // Gère l'affichage des scores
+  if(NScore!=Score) { // Gï¿½re l'affichage des scores
     if(Score!=-1) EffaceChiffre(740,215,Score);
     Score=NScore;
     AfficheChiffre(740,215,Score);
   }
 
-  if(NV>10) NV=10; // Evite un dépassement de l'affichage
+  if(NV>10) NV=10; // Evite un dï¿½passement de l'affichage
 
   while(NVie>NV) { // Si doit effacer des vies
     x=(NVie-1)%2;
diff -Naur Ri-li-2.0.1.orig/src/editeur.cc Ri-li-2.0.1/src/editeur.cc
--- Ri-li-2.0.1.orig/src/editeur.cc	2007-11-02 13:48:17.000000000 +0200
+++ Ri-li-2.0.1/src/editeur.cc	2008-05-11 10:01:21.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Editeur
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -25,7 +25,9 @@
 #include <windows.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
+using namespace std;
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -107,7 +109,7 @@
 	break;
       case SDL_MOUSEBUTTONUP:
 	Boutton=false;
-	if(TypeB!=-1 && Option==deco && cx>=LT) { // Si doit effacer une décoration
+	if(TypeB!=-1 && Option==deco && cx>=LT) { // Si doit effacer une dï¿½coration
 	  Niveau.T[NumN].NDeco--;
 	}
 	TypeB=-1;
@@ -118,15 +120,15 @@
       }
     }
     
-    // Gère l'appuis du boutton de la sourie
+    // Gï¿½re l'appuis du boutton de la sourie
     cx=Sourie.Px/D_Case;
     cy=Sourie.Py/D_Case;
     
     if(Boutton && cx<LT)
       switch(Option) {
       case deco:
-	if(TypeB==-1) { // Si première fois que appuis sur la touche
-	  for(i=0;i<Niveau.T[NumN].NDeco;i++) { // Recherche si décoration proche du clic
+	if(TypeB==-1) { // Si premiï¿½re fois que appuis sur la touche
+	  for(i=0;i<Niveau.T[NumN].NDeco;i++) { // Recherche si dï¿½coration proche du clic
 	    dx=Niveau.T[NumN].Deco[i].x-Sourie.Px;
 	    dy=Niveau.T[NumN].Deco[i].y-Sourie.Py;
 	    d=dx*dx+dy*dy;
@@ -134,7 +136,7 @@
 	      TypeB=i;
 	    }
 	  }
-	  if(TypeB==-1) { // Si doit fair un nouveau décor
+	  if(TypeB==-1) { // Si doit fair un nouveau dï¿½cor
 	    Niveau.T[NumN].NDeco++;
 	    Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].NumSpr=NumDeco;
 	    Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].x=Sourie.Px;
@@ -153,7 +155,7 @@
 	    NumDeco=Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].NumSpr;
 	  }	 
 	}
-	else { // Si pas la première fois remplace
+	else { // Si pas la premiï¿½re fois remplace
 	  Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].NumSpr=NumDeco;
 	  Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].x=Sourie.Px;
 	  Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].y=Sourie.Py;
@@ -191,7 +193,7 @@
 	break;
       }
     
-    // Gère les Horloges et la pose
+    // Gï¿½re les Horloges et la pose
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
@@ -236,7 +238,7 @@
     }
   }
   
-  // Affiche les décorations
+  // Affiche les dï¿½corations
   for(i=0;i<Niveau.T[NumN].NDeco;i++)
     Sprites[deco].Affiche(Niveau.T[NumN].Deco[i].x,Niveau.T[NumN].Deco[i].y,Niveau.T[NumN].Deco[i].NumSpr);
   
@@ -264,7 +266,7 @@
     }
   }
 
-  // Affiche le départ de la locomotive
+  // Affiche le dï¿½part de la locomotive
   switch(Niveau.T[NumN].DepDir) {
   case D_Haut:
     Sprites[locomotive].Affiche(Niveau.T[NumN].DepX*D_Case+D_Case/2,Niveau.T[NumN].DepY*D_Case+D_Case/2,0);
@@ -312,7 +314,7 @@
   else Sprites[deco].Affiche(Sourie.Px,Sourie.Py,NumDeco);
 }
 
-/*** Prend les touches enfoncées ***/
+/*** Prend les touches enfoncï¿½es ***/
 /***********************************/
 void Editeur::PrendTouche(int Tou)
 {  
diff -Naur Ri-li-2.0.1.orig/src/editeur.cc~ Ri-li-2.0.1/src/editeur.cc~
--- Ri-li-2.0.1.orig/src/editeur.cc~	1970-01-01 02:00:00.000000000 +0200
+++ Ri-li-2.0.1/src/editeur.cc~	2008-05-11 09:50:11.000000000 +0300
@@ -0,0 +1,406 @@
+//      (_||_/
+//      (    )       Classe Editeur
+//     ( o  0 )
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
+//                   Copyright (C) 2006 By Dominique Roux-Serret
+// .OOOo      oOOO.  roux-serret@ifrance.com
+//-(   )------(   )---------------------------------------
+//  ( (        ) /   Le 04/04/2006
+//   (_)      (_/
+
+//    This program is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 or version 3 of the License.
+
+//    This program is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+
+//    You should have received a copy of the GNU General Public License along
+//    with this program; if not, write to the Free Software Foundation, Inc.,
+//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#ifdef WINDOWS
+#include <windows.h>
+#endif
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <SDL/SDL.h>
+
+#include "editeur.h"
+#include "menu.h"
+#include "jeux.h"
+#include "tableau.h"
+#include "mouse.h"
+
+/*** Variables globales ***/
+/**************************/
+extern SDL_Surface *sdlVideo;
+
+extern Sprite *Sprites;
+extern sPreference Pref;
+
+extern int Horloge;
+extern int HorlogeAvant;
+
+extern Tableau Niveau;
+extern Mouse Sourie;
+extern Jeux Jeu;
+
+static int NumRail[]={ 10,10,10,0,10,1,2,3,10,4,5,6,7,8,9,10 };
+
+/*** Constructeur et Destructeur ***/
+/***********************************/
+Editeur::Editeur() : N(0), NumDeco(0)
+{ }
+
+Editeur::~Editeur()
+{ }
+
+/*** SDL Main ***/
+/****************/
+eMenu Editeur::SDLMain(int NumNiv)
+{
+  int PyE;
+  int cx=0,cy=0;
+  bool Boutton=false;
+  int TypeB=-1;
+  int i,d,dx,dy;
+  
+  NumN=NumNiv;
+
+  Affiche(); // Charge le tableau
+  SDL_Flip(sdlVideo);
+  
+  Horloge=SDL_GetTicks(); // Prend l'horloge
+  
+  Option=rail;
+
+  // Initialise la sourie
+  Sourie.Init(NULL);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) Affiche();
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  if(event.key.keysym.sym==SDLK_ESCAPE) return mMenu;
+	  else PrendTouche(event.key.keysym.sym);
+	}
+	break;
+      case SDL_MOUSEBUTTONDOWN:
+	if(event.button.state==SDL_PRESSED) {
+	  Boutton=true;
+	  TypeB=-1;
+	}
+	break;
+      case SDL_MOUSEBUTTONUP:
+	Boutton=false;
+	if(TypeB!=-1 && Option==deco && cx>=LT) { // Si doit effacer une dï¿½coration
+	  Niveau.T[NumN].NDeco--;
+	}
+	TypeB=-1;
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re l'appuis du boutton de la sourie
+    cx=Sourie.Px/D_Case;
+    cy=Sourie.Py/D_Case;
+    
+    if(Boutton && cx<LT)
+      switch(Option) {
+      case deco:
+	if(TypeB==-1) { // Si premiï¿½re fois que appuis sur la touche
+	  for(i=0;i<Niveau.T[NumN].NDeco;i++) { // Recherche si dï¿½coration proche du clic
+	    dx=Niveau.T[NumN].Deco[i].x-Sourie.Px;
+	    dy=Niveau.T[NumN].Deco[i].y-Sourie.Py;
+	    d=dx*dx+dy*dy;
+	    if(d<=(D_Case*2)*(D_Case*2)) { 
+	      TypeB=i;
+	    }
+	  }
+	  if(TypeB==-1) { // Si doit fair un nouveau dï¿½cor
+	    Niveau.T[NumN].NDeco++;
+	    Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].NumSpr=NumDeco;
+	    Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].x=Sourie.Px;
+	    Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].y=Sourie.Py;
+	    TypeB=1;
+	  }
+	  else { // Fait passe la selection au premier plan
+	    Niveau.T[NumN].Deco[Niveau.T[NumN].NDeco].NumSpr=Niveau.T[NumN].Deco[TypeB].NumSpr;
+	    Niveau.T[NumN].Deco[Niveau.T[NumN].NDeco].x=Niveau.T[NumN].Deco[TypeB].x;
+	    Niveau.T[NumN].Deco[Niveau.T[NumN].NDeco].y=Niveau.T[NumN].Deco[TypeB].y;
+	    for(d=TypeB;d<Niveau.T[NumN].NDeco;d++) {
+	      Niveau.T[NumN].Deco[d].NumSpr=Niveau.T[NumN].Deco[d+1].NumSpr;
+	      Niveau.T[NumN].Deco[d].x=Niveau.T[NumN].Deco[d+1].x;
+	      Niveau.T[NumN].Deco[d].y=Niveau.T[NumN].Deco[d+1].y;
+	    }
+	    NumDeco=Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].NumSpr;
+	  }	 
+	}
+	else { // Si pas la premiï¿½re fois remplace
+	  Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].NumSpr=NumDeco;
+	  Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].x=Sourie.Px;
+	  Niveau.T[NumN].Deco[(Niveau.T[NumN].NDeco-1)].y=Sourie.Py;
+	}
+	break;
+      case rail:
+	if(TypeB==-1) {
+	  if(Niveau.T[NumN].T[cy*LT+cx]!=C_Rail) TypeB=C_Rail;
+	  else TypeB=C_None;
+	}
+	Niveau.T[NumN].T[cy*LT+cx]=TypeB;
+	break;
+      case wagon:
+	Niveau.T[NumN].T[cy*LT+cx]=C_Wagon;
+ 	break;
+      case pluslong:
+	Niveau.T[NumN].T[cy*LT+cx]=C_Allonge;
+ 	break;
+      case pluscourt:
+	Niveau.T[NumN].T[cy*LT+cx]=C_Reduit;
+ 	break;
+      case vitesse:
+	Niveau.T[NumN].T[cy*LT+cx]=C_Speed;
+ 	break;
+      case vie:
+	Niveau.T[NumN].T[cy*LT+cx]=C_Live;
+ 	break;
+      case (e_Sprite)(locomotive+D_Haut):
+      case (e_Sprite)(locomotive+D_Bas):
+      case (e_Sprite)(locomotive+D_Gauche):
+      case (e_Sprite)(locomotive+D_Droite):
+	Niveau.T[NumN].DepX=cx;
+	Niveau.T[NumN].DepY=cy;
+	Niveau.T[NumN].DepDir=(int)(Option)-(int)(locomotive);
+	break;
+      }
+    
+    // Gï¿½re les Horloges et la pose
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+
+    // Fait l'affichage
+    Affiche();
+    SDL_Flip(sdlVideo);
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** Charge un tableau ***/
+/*************************/
+void Editeur::Affiche()
+{
+  int i,x,y,m,cx,cy;
+  unsigned char *T;
+
+  // Prend l'adresse du niveau
+  T=Niveau.T[NumN].T;
+
+  // Fabrique le fond du jeu
+  Sprites[fond].Affiche(400,300,0);
+  
+  // Affiche le circuit
+  for(i=0;i<LT*HT;i++) {
+    if(T[i]>=C_Rail && T[i]<C_Fin) {
+      y=i/LT*D_Case+D_Case/2;
+      x=i%LT*D_Case+D_Case/2;
+
+      m=0;
+      cx=i%LT;
+      cy=i/LT;
+      if(cy>0 && T[i-LT]>=1 && T[i-LT]<C_Fin) m+=8;
+      if(cy<HT-1 && T[i+LT]>=1 && T[i+LT]<C_Fin) m+=4;
+      if(cx>0 && T[i-1]>=1 && T[i-1]<C_Fin) m+=2;
+      if(cx<LT-1 && T[i+1]>=1 && T[i+1]<C_Fin) m+=1;
+      
+      Sprites[rail].Affiche(x,y,NumRail[m]);
+    }
+  }
+  
+  // Affiche les dï¿½corations
+  for(i=0;i<Niveau.T[NumN].NDeco;i++)
+    Sprites[deco].Affiche(Niveau.T[NumN].Deco[i].x,Niveau.T[NumN].Deco[i].y,Niveau.T[NumN].Deco[i].NumSpr);
+  
+  // Affiche numero du niveau
+  AfficheChiffre(740,130,NumN+1);
+  
+  // Affiche les options
+  for(i=0;i<LT*HT;i++) {
+    switch(T[i]) {
+    case C_Wagon: // Si un loco
+      Sprites[wagon].Affiche(i%LT*D_Case+D_Case/2,i/LT*D_Case+D_Case/2,25);
+      break;
+    case C_Allonge: // Si plus long
+      Sprites[pluslong].Affiche(i%LT*D_Case+D_Case/2,i/LT*D_Case+D_Case/2,25);
+      break;
+    case C_Reduit: // Si plus court
+      Sprites[pluscourt].Affiche(i%LT*D_Case+D_Case/2,i/LT*D_Case+D_Case/2,25);
+      break;
+    case C_Speed: // Si plus vite
+      Sprites[vitesse].Affiche(i%LT*D_Case+D_Case/2,i/LT*D_Case+D_Case/2,25);
+      break;
+    case C_Live: // Si une vie
+      Sprites[vie].Affiche(i%LT*D_Case+D_Case/2,i/LT*D_Case+D_Case/2,25);
+      break;
+    }
+  }
+
+  // Affiche le dï¿½part de la locomotive
+  switch(Niveau.T[NumN].DepDir) {
+  case D_Haut:
+    Sprites[locomotive].Affiche(Niveau.T[NumN].DepX*D_Case+D_Case/2,Niveau.T[NumN].DepY*D_Case+D_Case/2,0);
+    break;
+  case D_Bas:
+    Sprites[locomotive].Affiche(Niveau.T[NumN].DepX*D_Case+D_Case/2,Niveau.T[NumN].DepY*D_Case+D_Case/2,40);
+    break;
+  case D_Gauche:
+    Sprites[locomotive].Affiche(Niveau.T[NumN].DepX*D_Case+D_Case/2,Niveau.T[NumN].DepY*D_Case+D_Case/2,80);
+    break;
+  case D_Droite:
+    Sprites[locomotive].Affiche(Niveau.T[NumN].DepX*D_Case+D_Case/2,Niveau.T[NumN].DepY*D_Case+D_Case/2,120);
+    break;
+  }
+
+  // Affiche l'option choisi dans le menu
+  switch(Option) {
+  case rail:
+  case wagon:
+  case pluslong:
+  case pluscourt:
+  case vitesse:
+  case vie:
+    Sprites[Option].Affiche(740,200,0);
+    break;  
+  case (e_Sprite)(locomotive+D_Haut):
+    Sprites[locomotive].Affiche(740,200,0);
+    break;
+  case (e_Sprite)(locomotive+D_Bas):
+    Sprites[locomotive].Affiche(740,200,40);
+    break;
+  case (e_Sprite)(locomotive+D_Gauche):
+    Sprites[locomotive].Affiche(740,200,80);
+    break;
+  case (e_Sprite)(locomotive+D_Droite):
+    Sprites[locomotive].Affiche(740,200,120);
+    break;
+  case deco:
+    Sprites[deco].Affiche(740,200,NumDeco);
+    break;
+  }
+
+  // Affiche le curseur
+  if(Option!=deco) Sprites[curseur].Affiche(Sourie.Px,Sourie.Py,0);
+  else Sprites[deco].Affiche(Sourie.Px,Sourie.Py,NumDeco);
+}
+
+/*** Prend les touches enfoncï¿½es ***/
+/***********************************/
+void Editeur::PrendTouche(int Tou)
+{  
+  int i,j;
+  
+  switch(Tou) {
+  case SDLK_PAGEUP:
+    if(NumN<Niveau.N-1) NumN++;
+    else {
+      j=0;
+      for(i=0;i<LT*HT;i++) j+=Niveau.T[NumN].T[i];
+      if(j!=0) {
+	NumN++;
+	Niveau.N++;
+	Niveau.Clear(NumN);
+      }
+    }
+    break;
+  case SDLK_PAGEDOWN:
+    if(NumN) NumN--;
+    break;
+  case 'p':
+    Option=deco;
+    NumDeco++;
+    if(NumDeco>=Sprites[deco].N) NumDeco=0;
+    break;
+  case 'o':
+    Option=deco;
+    NumDeco--;
+    if(NumDeco<0) NumDeco=Sprites[deco].N-1;
+    break;
+  case SDLK_INSERT:
+    Niveau.Ins(NumN);
+    break;
+  case SDLK_DELETE:
+    Niveau.Del(NumN);
+    break;
+  case SDLK_UP:
+    Option=(e_Sprite)(locomotive+D_Haut);
+    break;
+  case SDLK_DOWN:
+    Option=(e_Sprite)(locomotive+D_Bas);
+    break;
+  case SDLK_LEFT:
+    Option=(e_Sprite)(locomotive+D_Gauche);
+    break;
+  case SDLK_RIGHT:
+    Option=(e_Sprite)(locomotive+D_Droite);
+    break;
+  case 'c':
+    Niveau.Clear(NumN);
+    break;
+  case '$':
+    // test si le dernier niveau est vide
+    for(j=i=0;i<LT*HT;i++) j+=Niveau.T[Niveau.N-1].T[i];
+    if(j==0) {
+      if(NumN<Niveau.N-1) Niveau.N--; // Si vide ne le compte pas
+    }
+    
+    // Sauve le niveau
+    if(Niveau.Save()==false) {
+      cerr <<"ERREUR Saving levels!"<<endl;
+      exit(-1);
+    }
+    
+    // test le niveau
+    Pref.Niveau=NumN;
+    Jeu.SDLMain();
+    Sourie.Init(NULL);
+    Affiche();
+    break;
+  case 'a':
+    Option=rail;
+    break;
+  case 'z':
+    Option=wagon;
+    break;
+  case 'e':
+    Option=pluslong;
+    break;
+  case 'r':
+    Option=pluscourt;
+    break;
+  case 't':
+    Option=vitesse;
+    break;
+  case 'y':
+    Option=vie;
+    break;
+  }
+}
diff -Naur Ri-li-2.0.1.orig/src/jeux.cc Ri-li-2.0.1/src/jeux.cc
--- Ri-li-2.0.1.orig/src/jeux.cc	2007-11-02 13:48:17.000000000 +0200
+++ Ri-li-2.0.1/src/jeux.cc	2008-05-11 09:50:20.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Jeux
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -25,7 +25,7 @@
 #include <windows.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -56,7 +56,7 @@
 
 static int NumRail[]={ -1,-1,-1,0,-1,1,2,3,-1,4,5,6,7,8,9,10 };
 
-int MasqueK; // Masque pour les touches de déplacement
+int MasqueK; // Masque pour les touches de dï¿½placement
 
 /*** Constructeur et Destructeur ***/
 /***********************************/
@@ -92,7 +92,7 @@
   DureeJeu=0;
   Key=0;
     
-  // Met le options de départ du joueur
+  // Met le options de dï¿½part du joueur
   Pref.NVie=N_VIES_DEP;
   Pref.Score=0;
   
@@ -108,7 +108,7 @@
 	  NumVideo=(NumVideo+1)&1;
 	  Ec[NumVideo].Cls(fjeu);
 	}
-	else { // Si désactive l'ecran
+	else { // Si dï¿½sactive l'ecran
 	  Pause=true; // Met en Pause
 	}
 	break;
@@ -171,10 +171,10 @@
       }
     }
     
-    // Gère l'appui des touches
+    // Gï¿½re l'appui des touches
     if(Key && Lo.Mort==-1) PrendTouche(Key);
 
-    // Gère les Horloges et la pose
+    // Gï¿½re les Horloges et la pose
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
@@ -251,7 +251,7 @@
   BufTouche(Niveau.T[NivN].DepDir);
   MasqueK=0;
 
-  // Met la vitesse suivant difficulté
+  // Met la vitesse suivant difficultï¿½
   switch(Pref.Difficulte) {
   case Easy:
     Pref.Vitesse=Pref.VitesseMoy=VITESSE_MIN;
@@ -293,7 +293,7 @@
     }
   }
 
-  // Affiche les décorations
+  // Affiche les dï¿½corations
 #ifndef DCHILDREN
   for(i=0;i<Niveau.T[NivN].NDeco;i++)
     Sprites[deco].Affiche(Niveau.T[NivN].Deco[i].x,Niveau.T[NivN].Deco[i].y,Niveau.T[NivN].Deco[i].NumSpr,
@@ -311,7 +311,7 @@
   return true;
 }
 
-/*** Prend les touches enfoncées ***/
+/*** Prend les touches enfoncï¿½es ***/
 /***********************************/
 void Jeux::PrendTouche(int Tou)
 {
@@ -387,10 +387,10 @@
   }
   while(Cherche==false);
   
-  BufTouche(To); // Mémorise la nouvelle touche par defaut.    
+  BufTouche(To); // Mï¿½morise la nouvelle touche par defaut.    
 }
   
-/*** Mémorise une touche dans le buffet des touches ***/
+/*** Mï¿½morise une touche dans le buffet des touches ***/
 /******************************************************/
 void Jeux::BufTouche(int Tou)
 {
@@ -399,15 +399,15 @@
   // Favorise la touche
   while(Touche[n]!=Tou) n++; // Prend position de la touche
 
-  if(n) { // Si changement doit faire un décalage
+  if(n) { // Si changement doit faire un dï¿½calage
     while(n) {
       Touche[n]=Touche[n-1];
       n--;
     }
-    Touche[0]=Tou; // Mémorise la touche
+    Touche[0]=Tou; // Mï¿½morise la touche
   }
  
-  // Cherche son oposé
+  // Cherche son oposï¿½
   switch(Tou) {
   case D_Haut:
     Tou=D_Bas;
@@ -423,16 +423,16 @@
     break;
   }
 
-  // Défavorise son oposé.
+  // Dï¿½favorise son oposï¿½.
   n=3;
   while(Touche[n]!=Tou) n--; // Prend position de la touche
   
-  if(n<3) { // Si changement doit faire un décalage
+  if(n<3) { // Si changement doit faire un dï¿½calage
     while(n<3) {
       Touche[n]=Touche[n+1];
       n++;
     }
-    Touche[3]=Tou; // Mémorise la touche
+    Touche[3]=Tou; // Mï¿½morise la touche
   }  
 }
 
@@ -470,7 +470,7 @@
   int i;
   int ndir=0;
 
-  // Prépare pour nouvelle Affichage
+  // Prï¿½pare pour nouvelle Affichage
   Ec[NumVideo].Efface(fjeu);
   
   // Fait nouvelle Affichage
diff -Naur Ri-li-2.0.1.orig/src/loco.cc Ri-li-2.0.1/src/loco.cc
--- Ri-li-2.0.1.orig/src/loco.cc	2007-11-02 13:48:18.000000000 +0200
+++ Ri-li-2.0.1/src/loco.cc	2008-05-11 09:50:30.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Loco
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,7 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -61,7 +61,7 @@
   int i;
   unsigned char Ar=0;
 
-  PLoco=0; // Pointe sur la première case
+  PLoco=0; // Pointe sur la premiï¿½re case
   PInter=-1;
   Vitesse=Reduit=Alonge=0; // Pas d'alongement
   Mort=-1;
@@ -92,7 +92,7 @@
   }
 
   // Initialise le Tableau et la loco
-  D=D_Case*1.99; // Positionne la tete presque à la fin
+  D=D_Case*1.99; // Positionne la tete presque ï¿½ la fin
 
   T[PLoco].P=Pos;
   T[PLoco].Arrive=Ar;
@@ -103,7 +103,7 @@
   Go(Direction);
   Go(Direction);
 
-  // Initialise la loco et son wagon à charbon
+  // Initialise la loco et son wagon ï¿½ charbon
   NWagon=2;
   Wagon[0]=locomotive;
   Wagon[1]=charbon;
@@ -153,15 +153,15 @@
     PosWagon[i].fx=x2;
     PosWagon[i].fy=y2;
     
-    // Calcule l'angle de rotation de la loco et le N° du Sprite
-    if(x1<=x2) { // Angle 0 à 180 compris
+    // Calcule l'angle de rotation de la loco et le Nï¿½ du Sprite
+    if(x1<=x2) { // Angle 0 ï¿½ 180 compris
       vy=(float)(x2-x1);
       vx=(float)(y2-y1);
       if(vx!=0) a=atan(vy/vx)*180.0/M_PI;
       else a=90.0;
       if(vx<0) a=180.0+a;
     }
-    else { // Angle 180.001 à 359.999
+    else { // Angle 180.001 ï¿½ 359.999
       vy=(float)(x1-x2);
       vx=(float)(y1-y2);
       if(vx!=0) a=atan(vy/vx)*180.0/M_PI+180.0;
@@ -187,7 +187,7 @@
     cfx=x1-(int)(sin(ar+M_PI)*lv);
     cfy=y1-(int)(cos(ar+M_PI)*lv);
     
-    // Cherche le N° du Sprite
+    // Cherche le Nï¿½ du Sprite
     switch( (int)a ) {
     case 0: // En haut
       ns=(int)(y1+D_Case/2)%(int)D_Case;
@@ -209,7 +209,7 @@
     
     Ec.Affiche(Wagon[i],ns,x1,y1);
 
-    // Si pas fini la sequence d'affiche de départ du wagon
+    // Si pas fini la sequence d'affiche de dï¿½part du wagon
     if(PosWagon[i].SprStart<N_SPR_START) {
       PosWagon[i].SprStart+=MemoDuree*N_SPR_START/750.0;
       if(PosWagon[i].SprStart<N_SPR_START) Ec.Affiche(nouveau_wagon,(int)(PosWagon[i].SprStart),x1,y1);
@@ -239,7 +239,7 @@
       Pref.Score+=5;
       AddLoco(); // Ajoute une loco au azard
  
-      Gagne=true; // Test si la dernière loco
+      Gagne=true; // Test si la derniï¿½re loco
       for(i=0;i<LT*HT;i++) if(Tableau[i]==C_Wagon) Gagne=false;
       if(Gagne) { 
 	Mort=Horloge+DUREE_PAUSE;
@@ -253,7 +253,7 @@
       if(Reduit>DureeJeu) Reduit=DureeJeu-1;
       else Alonge=DureeJeu+DUREE_ALONGE;
       break;
-    case C_Reduit: // Si réduit la loco
+    case C_Reduit: // Si rï¿½duit la loco
       Sons.Play(sReduit);
       Tableau[T[PLoco].P]=1; // efface l'option
       if(Alonge>DureeJeu) Alonge=DureeJeu-1;
@@ -304,14 +304,14 @@
   
   TestCase(Dist,DureeJeu,Tableau);
   
-  // Test si doit Réduire le wagon
+  // Test si doit Rï¿½duire le wagon
   if(Reduit>DureeJeu) {
-    if(Pref.EcartWagon>ECARTWAGON_MIN) { // Si doit réduire
+    if(Pref.EcartWagon>ECARTWAGON_MIN) { // Si doit rï¿½duire
       Pref.EcartWagon-=(float)(Duree)*(Pref.VitesseMoy*0.8/(float)(NWagon-1))/1000.0;
       if(Pref.EcartWagon<ECARTWAGON_MIN) Pref.EcartWagon=ECARTWAGON_MIN;
     }
   }
-  else { // Si temps est passé
+  else { // Si temps est passï¿½
     if(Pref.EcartWagon<ECARTWAGON_MOY) { // Si doit ralonger le wagon
       Pref.EcartWagon+=(float)(Duree)*(Pref.VitesseMoy*0.8/(float)(NWagon))/1000.0;
       if(Pref.EcartWagon>ECARTWAGON_MOY) Pref.EcartWagon=ECARTWAGON_MOY;
@@ -325,7 +325,7 @@
       if(Pref.EcartWagon>ECARTWAGON_MAX) Pref.EcartWagon=ECARTWAGON_MAX;
     }
   }
-  else { // Si temps est passé
+  else { // Si temps est passï¿½
     if(Pref.EcartWagon>ECARTWAGON_MOY) { // Si doit ralonger le wagon
       Pref.EcartWagon-=(float)(Duree)*(Pref.VitesseMoy*0.8/(float)(NWagon-1))/1000.0;
       if(Pref.EcartWagon<ECARTWAGON_MOY) Pref.EcartWagon=ECARTWAGON_MOY;
@@ -346,15 +346,15 @@
     }
   }
 
-  // Tand que dépasse la case en distante
+  // Tand que dï¿½passe la case en distante
   while(D+Dist>T[PLoco].D) {
-    Dist-=T[PLoco].D-D; // Enleve la distance restant à parcourir
+    Dist-=T[PLoco].D-D; // Enleve la distance restant ï¿½ parcourir
     D=T[PLoco].D;
     
     i=0; // Cherche la direction possible
     while(TestDir(Touche[i],Tableau)==false) i++;
     
-    Go(Touche[i]); // Fait avancer le loco suivant le désir du joueur
+    Go(Touche[i]); // Fait avancer le loco suivant le dï¿½sir du joueur
 
     DoFleche(Tableau,Touche); // Recherche la position de la futur intersection
 
@@ -362,7 +362,7 @@
 
   }
   
-  D+=Dist; // Met à la bonne position finale
+  D+=Dist; // Met ï¿½ la bonne position finale
   
   if(PInter==-1) DoFleche(Tableau,Touche);
 }
@@ -377,12 +377,12 @@
   int x,y,Tou;
   int i=0;
 
-  if(T[PLoco].P!=PInter && PInter!=-1) return; // Si pas encore arrivé sur la case de croisement
+  if(T[PLoco].P!=PInter && PInter!=-1) return; // Si pas encore arrivï¿½ sur la case de croisement
 
   PInter=T[PLoco].P; // Prend la position de la loco
 
   do {
-    // Vas à la nouvelle case
+    // Vas ï¿½ la nouvelle case
     switch(Sortie) {
     case D_Haut:
       PInter-=LT;
@@ -434,7 +434,7 @@
       Touche[i]=Touche[i-1];
       i--;
     }
-    Touche[0]=Tou; // Mémorise la touche
+    Touche[0]=Tou; // Mï¿½morise la touche
   }
   
 }
@@ -446,7 +446,7 @@
   int PAvant=T[PLoco].P;
   int x,y;
 
-  // Test si les directions ne sont pas opposées
+  // Test si les directions ne sont pas opposï¿½es
   if(T[PLoco].Sortie==D_Haut && FDir==D_Bas) return false;
   if(T[PLoco].Sortie==D_Bas && FDir==D_Haut) return false;
   if(T[PLoco].Sortie==D_Gauche && FDir==D_Droite) return false;
@@ -478,7 +478,7 @@
   int Mask;
   int i;
 
-  // Test si risque de dépassement et enleve une bonne partie
+  // Test si risque de dï¿½passement et enleve une bonne partie
   if(PLoco==255) {
     for(i=0;i<256-50;i++) {
       T[i].P=T[i+50].P;
@@ -489,8 +489,8 @@
     PLoco-=50;
   }
   
-  // Mémorise la prochaine case
-  PLoco++; // Passe à la case suivante
+  // Mï¿½morise la prochaine case
+  PLoco++; // Passe ï¿½ la case suivante
 
   switch(Dir) {
   case D_Haut:
@@ -510,7 +510,7 @@
     T[PLoco].Arrive=D_Gauche;
   }
 
-  // Donne futur direction et N° case avant
+  // Donne futur direction et Nï¿½ case avant
   T[PLoco].P=PTab;
   T[PLoco].Sortie=FuturDir;
 
@@ -543,7 +543,7 @@
   while(T[NP-1].D>Dist) NP--;
   P=T[NP].P;
 
-  // Calcule les coordonnée suivant la direction
+  // Calcule les coordonnï¿½e suivant la direction
   D_Rest=T[NP].D-Dist;
   if(D_Rest==0) D_Rest=D_Case/1000.0; // Evite les erreurs de division
 
diff -Naur Ri-li-2.0.1.orig/src/main.cc Ri-li-2.0.1/src/main.cc
--- Ri-li-2.0.1.orig/src/main.cc	2007-11-02 13:48:19.000000000 +0200
+++ Ri-li-2.0.1/src/main.cc	2008-05-11 10:00:48.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Programme Principale
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,9 +21,11 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
+#include <iostream>
+using namespace std;
+
 #include <stdio.h>
 #include <stdlib.h>
-#include <iostream.h>
 #include <string.h>
 #include <SDL/SDL.h>
 #include <SDL/SDL_mixer.h>
@@ -41,22 +43,22 @@
 
 /*** Variables globales ***/
 /************************/
-SDL_Surface *sdlVideo; // Pointe sur l'écran video
+SDL_Surface *sdlVideo; // Pointe sur l'ï¿½cran video
 SDL_VideoInfo *sdlVideoInfo; // Infos sur la video
-Uint32 FontColor;      // Couleur du fond d'écran
+Uint32 FontColor;      // Couleur du fond d'ï¿½cran
 
 char Titre[]="Ri-li V2.0.1";
 
 Sprite *Sprites=NULL; // Pointe sur les sprites
-int NSprites=0; // Nombre de sprites en mémoire
-Ecran Ec[2];          // Pointe sur les 2 buffets vidéo
-sPreference Pref;     // Tableau des préférences.
-Jeux Jeu;             // Gère le jeu
-Mouse Sourie;         // Gère les mouvements de sourie
-Menu MenuPrincipale;  // Gère les menus
-Tableau Niveau;       // Gère les niveaux
-Editeur Edit;         // Gère le menu de l'éditeur
-Audio Sons;           // Gère les sons
+int NSprites=0; // Nombre de sprites en mï¿½moire
+Ecran Ec[2];          // Pointe sur les 2 buffets vidï¿½o
+sPreference Pref;     // Tableau des prï¿½fï¿½rences.
+Jeux Jeu;             // Gï¿½re le jeu
+Mouse Sourie;         // Gï¿½re les mouvements de sourie
+Menu MenuPrincipale;  // Gï¿½re les menus
+Tableau Niveau;       // Gï¿½re les niveaux
+Editeur Edit;         // Gï¿½re le menu de l'ï¿½diteur
+Audio Sons;           // Gï¿½re les sons
 
 int Horloge=0; // Horloges du jeu
 int HorlogeAvant=0;
@@ -107,7 +109,7 @@
   Sprite Spr;
   eMenu RetM,RetMenu=mMenu;
 
-  // Initialuse les préferences
+  // Initialuse les prï¿½ferences
   InitPref();
 #ifdef LINUX
   if(narg>1) strcpy(DefPath,argv[1]);
@@ -125,14 +127,14 @@
   sdlVideoInfo=(SDL_VideoInfo*)SDL_GetVideoInfo();
 
   if(sdlVideoInfo->vfmt->BitsPerPixel==8) {
-    cerr <<"Impossible d'utiliser 8bits pour la vidéo !"<<endl;
+    cerr <<"Impossible d'utiliser 8bits pour la vidï¿½o !"<<endl;
     exit(-1);
   }
   
   // Demande la resolution Video
 #ifndef LINUX
   int vOption;
-  if(Pref.FullScreen)   vOption=SDL_SWSURFACE; // Bug accé aux bits pour les cordes
+  if(Pref.FullScreen)   vOption=SDL_SWSURFACE; // Bug accï¿½ aux bits pour les cordes
   else  vOption=SDL_SWSURFACE|SDL_DOUBLEBUF;
 #else
 #ifndef __AMIGAOS4__
@@ -145,7 +147,7 @@
   sdlVideo=SDL_SetVideoMode(800,600,sdlVideoInfo->vfmt->BitsPerPixel,vOption);
 
   if(sdlVideo==NULL) {
-    cerr <<"Impossible de passer dans le mode vidéo 800x600 !"<<endl;
+    cerr <<"Impossible de passer dans le mode vidï¿½o 800x600 !"<<endl;
     exit(-1);
   }
   // Change le nom de la fenetre
@@ -154,7 +156,7 @@
   SDL_ShowCursor(0); // Masque le curseur
   SDL_EnableUNICODE(1);
 
-  // Couleur du font d'écran
+  // Couleur du font d'ï¿½cran
   FontColor=SDL_MapRGB(sdlVideo->format,128,128,128);
 
   // Chargement des sprites
@@ -172,7 +174,7 @@
   // Si pas de langues demande la langue
   if(Pref.Langue==-1) MenuPrincipale.SDLMain_Langue();
   
-  // Gère les menus
+  // Gï¿½re les menus
   do {
     switch(RetMenu) {
     case mMenu:
diff -Naur Ri-li-2.0.1.orig/src/main.cc~ Ri-li-2.0.1/src/main.cc~
--- Ri-li-2.0.1.orig/src/main.cc~	1970-01-01 02:00:00.000000000 +0200
+++ Ri-li-2.0.1/src/main.cc~	2008-05-11 09:59:13.000000000 +0300
@@ -0,0 +1,228 @@
+//      (_||_/
+//      (    )       Programme Principale
+//     ( o  0 )
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
+//                   Copyright (C) 2006 By Dominique Roux-Serret
+// .OOOo      oOOO.  roux-serret@ifrance.com
+//-(   )------(   )---------------------------------------
+//  ( (        ) /   Le 03/01/2006
+//   (_)      (_/
+
+//    This program is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 or version 3 of the License.
+
+//    This program is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+
+//    You should have received a copy of the GNU General Public License along
+//    with this program; if not, write to the Free Software Foundation, Inc.,
+//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#include <iostream>
+using std::cerr;
+using std::endl;
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <SDL/SDL.h>
+#include <SDL/SDL_mixer.h>
+
+#include "preference.h"
+#include "jeux.h"
+#include "audio.h"
+#include "sprite.h"
+#include "ecran.h"
+#include "mouse.h"
+#include "menu.h"
+#include "tableau.h"
+#include "editeur.h"
+#include "utils.h"
+
+/*** Variables globales ***/
+/************************/
+SDL_Surface *sdlVideo; // Pointe sur l'ï¿½cran video
+SDL_VideoInfo *sdlVideoInfo; // Infos sur la video
+Uint32 FontColor;      // Couleur du fond d'ï¿½cran
+
+char Titre[]="Ri-li V2.0.1";
+
+Sprite *Sprites=NULL; // Pointe sur les sprites
+int NSprites=0; // Nombre de sprites en mï¿½moire
+Ecran Ec[2];          // Pointe sur les 2 buffets vidï¿½o
+sPreference Pref;     // Tableau des prï¿½fï¿½rences.
+Jeux Jeu;             // Gï¿½re le jeu
+Mouse Sourie;         // Gï¿½re les mouvements de sourie
+Menu MenuPrincipale;  // Gï¿½re les menus
+Tableau Niveau;       // Gï¿½re les niveaux
+Editeur Edit;         // Gï¿½re le menu de l'ï¿½diteur
+Audio Sons;           // Gï¿½re les sons
+
+int Horloge=0; // Horloges du jeu
+int HorlogeAvant=0;
+
+#ifdef LINUX
+char DefPath[256]; // Chemin par defaut dans arg
+#endif
+
+/*** Initialise les preferences ***/
+/**********************************/
+void InitPref(void)
+{
+#ifdef LINUX
+  DefPath[0]=0;
+#endif
+
+  Pref.NiveauMax=0;
+  Pref.FullScreen=false;
+  Pref.Langue=-1;
+  Pref.Volume=(float)SDL_MIX_MAXVOLUME;
+  Pref.VolumeM=(float)SDL_MIX_MAXVOLUME; //*6.0/10.0;
+
+  for(int i=0;i<8;i++) { // Vide les scores
+    Pref.Sco[i].Score=0;
+    Pref.Sco[i].Name[0]=0;
+  }
+/*   Pref.Sco[0].Score=11425; */
+/*   sprintf(Pref.Sco[0].Name,"%s","Dominique"); */
+/*   Pref.Sco[1].Score=678; */
+/*   sprintf(Pref.Sco[1].Name,"%s","Veronique"); */
+
+  LoadPref();
+
+  Pref.Difficulte=Normal;
+  Pref.Vitesse=VITESSE_MOY;
+  Pref.VitesseMoy=VITESSE_MOY;
+  Pref.NVie=N_VIES_DEP;
+  Pref.EcartWagon=ECARTWAGON_MOY;
+}
+
+/*** Preogramme principale ***/
+/*****************************/
+int main(int narg,char *argv[])
+{
+  int i;
+  char **pTitre=NULL;
+  char **pIcon=NULL;
+  Sprite Spr;
+  eMenu RetM,RetMenu=mMenu;
+
+  // Initialuse les prï¿½ferences
+  InitPref();
+#ifdef LINUX
+  if(narg>1) strcpy(DefPath,argv[1]);
+#endif
+ 
+  // Initilise SDL
+  if( SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_AUDIO|SDL_INIT_NOPARACHUTE) < 0 ) {
+    cerr <<"Impossible d'initialiser SDL:"<<SDL_GetError()<<endl;
+    exit(-1);
+  }
+  // Ferme le programme correctement quant quit
+  atexit(SDL_Quit);
+    
+  // Teste la resolution video
+  sdlVideoInfo=(SDL_VideoInfo*)SDL_GetVideoInfo();
+
+  if(sdlVideoInfo->vfmt->BitsPerPixel==8) {
+    cerr <<"Impossible d'utiliser 8bits pour la vidï¿½o !"<<endl;
+    exit(-1);
+  }
+  
+  // Demande la resolution Video
+#ifndef LINUX
+  int vOption;
+  if(Pref.FullScreen)   vOption=SDL_SWSURFACE; // Bug accï¿½ aux bits pour les cordes
+  else  vOption=SDL_SWSURFACE|SDL_DOUBLEBUF;
+#else
+#ifndef __AMIGAOS4__
+  int vOption=SDL_SWSURFACE|SDL_DOUBLEBUF;
+#else
+  int vOption=SDL_SWSURFACE;
+#endif
+#endif
+  if(Pref.FullScreen) vOption|=SDL_FULLSCREEN;
+  sdlVideo=SDL_SetVideoMode(800,600,sdlVideoInfo->vfmt->BitsPerPixel,vOption);
+
+  if(sdlVideo==NULL) {
+    cerr <<"Impossible de passer dans le mode vidï¿½o 800x600 !"<<endl;
+    exit(-1);
+  }
+  // Change le nom de la fenetre
+  SDL_WM_GetCaption(pTitre,pIcon);
+  SDL_WM_SetCaption(Titre,NULL);
+  SDL_ShowCursor(0); // Masque le curseur
+  SDL_EnableUNICODE(1);
+
+  // Couleur du font d'ï¿½cran
+  FontColor=SDL_MapRGB(sdlVideo->format,128,128,128);
+
+  // Chargement des sprites
+  Sons.Init();
+  if(LoadSprites()==false) exit(-1);
+  if(Niveau.Load()==false) exit(-1);
+
+  Sons.PlayMusic();
+  Sourie.InitStart();
+
+  // Initialise l'horloge et le hazard
+  HorlogeAvant=Horloge=SDL_GetTicks();
+  srand(SDL_GetTicks());
+
+  // Si pas de langues demande la langue
+  if(Pref.Langue==-1) MenuPrincipale.SDLMain_Langue();
+  
+  // Gï¿½re les menus
+  do {
+    switch(RetMenu) {
+    case mMenu:
+      RetM=MenuPrincipale.SDLMain();
+      break;
+    case mLangue:
+      RetM=MenuPrincipale.SDLMain_Langue();
+      break;
+    case mOption:
+      RetM=MenuPrincipale.SDLMain_Options();
+      break;
+    case mScoreEdit:
+      RetM=MenuPrincipale.SDLMain_Score(true);
+      break;
+    case mScore:
+      RetM=MenuPrincipale.SDLMain_Score();
+      break;
+    case mMenuSpeed:
+      RetM=MenuPrincipale.SDLMain_Speed();
+      break;
+    case mMenuNiveau:
+      RetM=MenuPrincipale.SDLMain_Niveau();
+      break;
+    case mJeux:
+      Sons.LoadMusic(1);
+      RetM=Jeu.SDLMain();
+      Sons.LoadMusic(0);
+      break;
+    case mEdit:
+      RetM=Edit.SDLMain(0);
+      break;
+    default:
+      RetM=mQuit;
+    }
+    RetMenu=RetM;
+  } while(RetMenu!=mQuit);
+  
+  // Ferme proprement le programme
+  Mix_HaltMusic(); // Arrete la music
+  Mix_FreeMusic(Sons.Music); // Efface la music
+  
+  for(i=0;i<NSprites;i++) { // Efface les sprites
+    Sprites[i].Delete();
+  }
+  delete [] Sprites;
+
+  SauvePref(); // Sauve les preferences
+
+  exit(0);
+}
diff -Naur Ri-li-2.0.1.orig/src/menu.cc Ri-li-2.0.1/src/menu.cc
--- Ri-li-2.0.1.orig/src/menu.cc	2007-11-02 13:48:19.000000000 +0200
+++ Ri-li-2.0.1/src/menu.cc	2008-05-11 10:00:33.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Menu
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,9 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
+using namespace std;
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -69,7 +71,7 @@
 Menu::~Menu()
 { }
 
-/*** Ajoute une entrée dans le tableau des boutons ***/
+/*** Ajoute une entrï¿½e dans le tableau des boutons ***/
 /*****************************************************/
 void AddBouton(int Num,e_Sprite NumSp,int X,int Y)
 {
@@ -83,7 +85,7 @@
   Menu_Py[Num].Valide=true;
 }
 
-/*** Change le vidéo ***/
+/*** Change le vidï¿½o ***/
 /***********************/
 void ChangeVideo(void)
 {
@@ -92,14 +94,14 @@
   // Teste la resolution video
   sdlVideoInfo=(SDL_VideoInfo*)SDL_GetVideoInfo();
   if(sdlVideoInfo->vfmt->BitsPerPixel==8) {
-    cerr <<"Impossible d'utiliser 8bits pour la vidéo !"<<endl;
+    cerr <<"Impossible d'utiliser 8bits pour la vidï¿½o !"<<endl;
     exit(-1);
   }
   
   // Demande la resolution Video
 #ifndef LINUX
   int vOption;
-  if(Pref.FullScreen)   vOption=SDL_SWSURFACE; // Bug accé aux bits pour les cordes
+  if(Pref.FullScreen)   vOption=SDL_SWSURFACE; // Bug accï¿½ aux bits pour les cordes
   else  vOption=SDL_SWSURFACE|SDL_DOUBLEBUF;
 #else
 #ifndef __AMIGAOS4__
@@ -112,7 +114,7 @@
   if(Pref.FullScreen) vOption|=SDL_FULLSCREEN;
   sdlVideo=SDL_SetVideoMode(800,600,sdlVideoInfo->vfmt->BitsPerPixel,vOption);
   if(sdlVideo==NULL) {
-    cerr <<"Impossible de passer dans le mode vidéo 800x600 !"<<endl;
+    cerr <<"Impossible de passer dans le mode vidï¿½o 800x600 !"<<endl;
     exit(-1);
   }
   
@@ -199,9 +201,9 @@
 	    }
 	    break;
 	  default:
-	    key=event.key.keysym.unicode&0x7F; // Prend le caracataire correspondant à la touche
+	    key=event.key.keysym.unicode&0x7F; // Prend le caracataire correspondant ï¿½ la touche
 	    if(CharExiste(key)==true) { // Si la caractaire existe bien
-	      for(i=2;i>=0;i--) MCode[i+1]=MCode[i]; // décale le code
+	      for(i=2;i>=0;i--) MCode[i+1]=MCode[i]; // dï¿½cale le code
 	      MCode[0]=key;
 	      if(strcmp(MCode,"tide")==0 || strcmp(MCode,"TIDE")==0) return mEdit; // Si editeur de niveau
 	    } 
@@ -214,12 +216,12 @@
       }
     }
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
     Affiche_Main();
     Sourie.Affiche(NumEc);
@@ -327,12 +329,12 @@
       }
     }
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
 
     Affiche_Main_Centre();
@@ -372,7 +374,7 @@
 
   AddBouton(3,monde,180,400);
 
-  // Centre à gauche le text de menu
+  // Centre ï¿½ gauche le text de menu
   CentreM=120+Sprites[T_menu].Dim[0].L/2;
   AfficheText(CentreM,490,T_menu,Sprites[fmenu].Image[0]);
   AddBouton(4,T_menu,CentreM,490);
@@ -427,7 +429,7 @@
   int i,N;
   int NumSp;
 
-  InitMain_Options(); // Prépare le menu
+  InitMain_Options(); // Prï¿½pare le menu
 
   // Prend les evenements
   do {
@@ -566,12 +568,12 @@
       }
     }
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
 
     if(Pref.FullScreen) {
@@ -645,7 +647,7 @@
   return mQuit;
 }
 
-/*** SDL Main Menu Choix de la difficulté ***/
+/*** SDL Main Menu Choix de la difficultï¿½ ***/
 /********************************************/
 eMenu Menu::SDLMain_Speed(void)
 {
@@ -727,12 +729,12 @@
       }
     }
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
     Affiche_Main();
     Sourie.Affiche(NumEc);
@@ -756,7 +758,7 @@
   Niv=Pref.NiveauMax;
   Pref.Niveau=0;
 
-  if(Niv==0) return mMenuSpeed; // Inutile si la première fois
+  if(Niv==0) return mMenuSpeed; // Inutile si la premiï¿½re fois
 
   // Prend l'image du fond et fait l'affichage 
   Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
@@ -848,16 +850,16 @@
       }
     }
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
     EffaceChiffre(400,380,999,Sprites[fmenu].Image[0]);
 
-    // Affiche les flèches
+    // Affiche les flï¿½ches
     if(Niv>0) {
       if(PyE==3) Ec[NumEc].Affiche(fleches,2,330,380);
       else Ec[NumEc].Affiche(fleches,1,330,380);
@@ -1009,12 +1011,12 @@
     // Test si fini
     if(Fini!=-1 && Fini<Horloge) return mJeux;
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
   
     if(Ordre) {
@@ -1146,12 +1148,12 @@
       }
     }
     
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
     Affiche_Main(340);
     Sourie.Affiche(NumEc);
@@ -1165,7 +1167,7 @@
   return mQuit;
 }
 
-/*** SDL Main Menu Choix de la difficulté ***/
+/*** SDL Main Menu Choix de la difficultï¿½ ***/
 /********************************************/
 eMenu Menu::SDLMain_Score(bool EditScore)
 {
@@ -1175,12 +1177,12 @@
   int PosCur=0;
   char key;
 
-  // Cherche le numéro du score à remplacer si edition des scores
+  // Cherche le numï¿½ro du score ï¿½ remplacer si edition des scores
   if(EditScore) {
     for(i=7;i>=0;i--) if(Pref.Sco[i].Score<Pref.Score) NEdit=i;
     if(NEdit==-1) return mMenu;
 
-    if(NEdit<7) // Si doit fair un décalage
+    if(NEdit<7) // Si doit fair un dï¿½calage
       for(i=7;i>NEdit;i--) {
 	Pref.Sco[i].Score=Pref.Sco[i-1].Score;
 	strcpy(Pref.Sco[i].Name,Pref.Sco[i-1].Name);
@@ -1250,7 +1252,7 @@
 	  case SDLK_F12: // Sauve un screenshot
 	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
 	    break;   
-	  case SDLK_ESCAPE: // Valide l'entrée
+	  case SDLK_ESCAPE: // Valide l'entrï¿½e
 	  case SDLK_RETURN:
 	  case SDLK_KP_ENTER:
 	    return mMenu;
@@ -1261,7 +1263,7 @@
 	    }
 	    break;
 	  default: // Prend les touches
-	    key=event.key.keysym.unicode&0x7F; // Prend le caracataire correspondant à la touche
+	    key=event.key.keysym.unicode&0x7F; // Prend le caracataire correspondant ï¿½ la touche
 	    if(PosCur<79 && CharExiste(key)==true) { // Prend le caractaire
 	      Pref.Sco[NEdit].Name[PosCur]=key;
 	      Pref.Sco[NEdit].Name[PosCur+1]=0;
@@ -1281,15 +1283,15 @@
       }
     }
 
-    // Gère les variables
+    // Gï¿½re les variables
     HorlogeAvant=Horloge;
     Horloge=SDL_GetTicks();
     Sleeping();
     
-    // Gère l'Affichage
+    // Gï¿½re l'Affichage
     Ec[NumEc].Efface(fmenu);
 
-    if(EditScore) { // Gère l'affiche pour l'édition des scores
+    if(EditScore) { // Gï¿½re l'affiche pour l'ï¿½dition des scores
       Sprites[fmenu].EffaceCarre(140,120-360/14+NEdit*(360/7),140+LSCOREMAX,120-360/14+(NEdit+1)*(360/7),
 				 Sprites[fmenu].Image[0]);
       AfficheString(140,120+NEdit*(360/7),Pref.Sco[NEdit].Name);
@@ -1322,7 +1324,7 @@
   Ec[NumEc].Affiche(fleche_droite,NumSp,x2,y);
 }
 
-/*** Centre les flèches sur le boutton ***/
+/*** Centre les flï¿½ches sur le boutton ***/
 /*****************************************/
 void Menu::Affiche_Main_Centre()
 {
diff -Naur Ri-li-2.0.1.orig/src/menu.cc~ Ri-li-2.0.1/src/menu.cc~
--- Ri-li-2.0.1.orig/src/menu.cc~	1970-01-01 02:00:00.000000000 +0200
+++ Ri-li-2.0.1/src/menu.cc~	2008-05-11 09:50:45.000000000 +0300
@@ -0,0 +1,1336 @@
+//      (_||_/
+//      (    )       Classe Menu
+//     ( o  0 )
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
+//                   Copyright (C) 2006 By Dominique Roux-Serret
+// .OOOo      oOOO.  roux-serret@ifrance.com
+//-(   )------(   )---------------------------------------
+//  ( (        ) /   Le 23/03/2006
+//   (_)      (_/
+
+//    This program is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 or version 3 of the License.
+
+//    This program is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+
+//    You should have received a copy of the GNU General Public License along
+//    with this program; if not, write to the Free Software Foundation, Inc.,
+//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "preference.h"
+#include "menu.h"
+#include "sprite.h"
+#include "ecran.h"
+#include "mouse.h"
+#include "audio.h"
+
+#define PY 180
+
+/*** Variables globales ***/
+/**************************/
+extern int Horloge;
+extern int HorlogeAvant;
+extern SDL_Surface *sdlVideo;
+extern Sprite *Sprites;
+extern Mouse Sourie;
+extern Ecran Ec[2];
+extern sPreference Pref;
+extern Audio Sons;
+
+static char Points[]=". . . . . . . . . . . . . .";
+static struct mPy Menu_Py[20];
+
+/*** Fait une attente pour 50fps ***/
+/***********************************/
+void Sleeping()
+{
+  int delay;
+
+  if( (Horloge-HorlogeAvant) < (1000/60) ) {
+    delay=1000/60-(Horloge-HorlogeAvant);
+    SDL_Delay(delay);
+    Horloge=SDL_GetTicks();
+  }
+}
+
+/*** Constructeur et Destructeur ***/
+/***********************************/
+Menu::Menu() : PyE(0)
+{ }
+
+Menu::~Menu()
+{ }
+
+/*** Ajoute une entrï¿½e dans le tableau des boutons ***/
+/*****************************************************/
+void AddBouton(int Num,e_Sprite NumSp,int X,int Y)
+{
+  int NumS=(int)NumSp;
+
+  Menu_Py[Num].DepX=X-Sprites[NumS].Dim[0].L/2;
+  Menu_Py[Num].DepY=Y-Sprites[NumS].Dim[0].H/2;
+  Menu_Py[Num].FinX=X+Sprites[NumS].Dim[0].L/2;
+  Menu_Py[Num].FinY=Y+Sprites[NumS].Dim[0].H/2;
+  Menu_Py[Num].Py=Num;
+  Menu_Py[Num].Valide=true;
+}
+
+/*** Change le vidï¿½o ***/
+/***********************/
+void ChangeVideo(void)
+{
+  SDL_VideoInfo *sdlVideoInfo;
+
+  // Teste la resolution video
+  sdlVideoInfo=(SDL_VideoInfo*)SDL_GetVideoInfo();
+  if(sdlVideoInfo->vfmt->BitsPerPixel==8) {
+    cerr <<"Impossible d'utiliser 8bits pour la vidï¿½o !"<<endl;
+    exit(-1);
+  }
+  
+  // Demande la resolution Video
+#ifndef LINUX
+  int vOption;
+  if(Pref.FullScreen)   vOption=SDL_SWSURFACE; // Bug accï¿½ aux bits pour les cordes
+  else  vOption=SDL_SWSURFACE|SDL_DOUBLEBUF;
+#else
+#ifndef __AMIGAOS4__
+  int vOption=SDL_SWSURFACE|SDL_DOUBLEBUF;
+#else
+  int vOption=SDL_SWSURFACE;
+#endif
+#endif
+
+  if(Pref.FullScreen) vOption|=SDL_FULLSCREEN;
+  sdlVideo=SDL_SetVideoMode(800,600,sdlVideoInfo->vfmt->BitsPerPixel,vOption);
+  if(sdlVideo==NULL) {
+    cerr <<"Impossible de passer dans le mode vidï¿½o 800x600 !"<<endl;
+    exit(-1);
+  }
+  
+  SDL_ShowCursor(0); // Cache le curseur
+}
+
+/*** SDL Main Menu principale ***/
+/********************************/
+eMenu Menu::SDLMain(void)
+{
+  int i;
+  char MCode[5]={0,0,0,0,0};
+  char key;
+
+  // Initialisations Divers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=0;
+  
+  // Prend l'image du fond et fait l'affichage 
+  Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  Sprites[menu].Affiche(400,340,0,Sprites[fmenu].Image[0]);
+  Sprites[titre].Affiche(400,65,0,Sprites[fmenu].Image[0]);
+  Sprites[copyright].Affiche(400,587,0,Sprites[fmenu].Image[0]);
+
+  AfficheText(400,229,T_play,Sprites[fmenu].Image[0]);
+  AddBouton(0,T_play,400,229);
+  AfficheText(400,306,T_scores,Sprites[fmenu].Image[0]);
+  AddBouton(1,T_scores,400,306);
+  AfficheText(400,384,T_moptions,Sprites[fmenu].Image[0]);
+  AddBouton(2,T_moptions,400,384);
+  AfficheText(400,461,T_quit,Sprites[fmenu].Image[0]);
+  AddBouton(3,T_quit,400,461);
+  Menu_Py[4].DepX=-1;
+
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    return mQuit;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0) PyE=3;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>3) PyE=0;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    switch(PyE) {
+	    case 0:
+	      return mMenuNiveau;
+	    case 1:
+	      return mScore;
+	    case 2:
+	      return mOption;
+	    case 3:
+	      return mQuit;
+	    }
+	    break;
+	  default:
+	    key=event.key.keysym.unicode&0x7F; // Prend le caracataire correspondant ï¿½ la touche
+	    if(CharExiste(key)==true) { // Si la caractaire existe bien
+	      for(i=2;i>=0;i--) MCode[i+1]=MCode[i]; // dï¿½cale le code
+	      MCode[0]=key;
+	      if(strcmp(MCode,"tide")==0 || strcmp(MCode,"TIDE")==0) return mEdit; // Si editeur de niveau
+	    } 
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+    Affiche_Main();
+    Sourie.Affiche(NumEc);
+    
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** SDL Main Menu Choix de la langue ***/
+/****************************************/
+eMenu Menu::SDLMain_Langue(void)
+{
+  int NCol=1;
+  int NL;
+  int Ecart;
+  int i;
+  int x,y;
+  int OldLangue=Pref.Langue;
+
+  // Initialisations Divers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=Pref.Langue;
+  if(PyE==-1) PyE=1;
+
+  // Prend l'image du fond et fait l'affichage 
+  Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  
+  // Affiche les langues possibles
+  NCol=3;
+  if(Pref.NLangues%NCol==0) NL=Pref.NLangues/NCol;
+  else NL=Pref.NLangues/NCol+1;
+  Ecart=600/(NL+1);
+
+  for(i=0;i<Pref.NLangues;i++) {
+    x=(i/NL)*(800/3)+(800/6);
+    y=(i%NL)*Ecart+Ecart;
+    
+    Sprites[T_Langue+i].Affiche(x,y,0,Sprites[fmenu].Image[0]);
+    AddBouton(i,(e_Sprite)(T_Langue+i),x,y);
+  }
+  
+  Menu_Py[Pref.NLangues].DepX=-1;
+
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    if(Pref.Langue==-1) Pref.Langue=PyE;
+	    return mMenu;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0) PyE=Pref.NLangues-1;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>=Pref.NLangues) PyE=0;
+	    break;
+	  case SDLK_LEFT:
+	    if(PyE-NL>=0) PyE-=NL;
+	    break;
+	  case SDLK_RIGHT:
+	    if(PyE+NL<Pref.NLangues) PyE+=NL;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    Pref.Langue=PyE;
+	    if(Pref.Langue!=OldLangue) LoadLangue();
+	    return mMenu;
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+
+    Affiche_Main_Centre();
+
+    Sourie.Affiche(NumEc);
+
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** SDL Main Menu Choix des Options ***/
+/***************************************/
+void Menu::InitMain_Options(void)
+{
+  // Initialisations Divers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=4;
+
+  // Prend l'image du fond et fait l'affichage 
+  Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  Sprites[gmenu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  Sprites[keys].Affiche(610,455,0,Sprites[fmenu].Image[0]);
+
+  AddBouton(0,bruitage,140,110);
+  AddBouton(1,music,160,200);
+
+  AddBouton(2,fscreen,190,300);
+  Menu_Py[2].DepX-=40;
+  Menu_Py[2].FinX=625+40+Sprites[fscreen].Dim[0].L/2;
+  Sprites[fscreen].Affiche(185,300,0,Sprites[fmenu].Image[0]);
+  Sprites[window].Affiche(625,300,0,Sprites[fmenu].Image[0]);
+
+  AddBouton(3,monde,180,400);
+
+  // Centre ï¿½ gauche le text de menu
+  CentreM=120+Sprites[T_menu].Dim[0].L/2;
+  AfficheText(CentreM,490,T_menu,Sprites[fmenu].Image[0]);
+  AddBouton(4,T_menu,CentreM,490);
+
+  // Boutons des bruitages
+  Sprites[fleches].Affiche(250,110,1,Sprites[fmenu].Image[0]);
+  Sprites[fleches].Affiche(700,110,4,Sprites[fmenu].Image[0]);
+  Menu_Py[5].DepX=230;
+  Menu_Py[5].DepY=70;
+  Menu_Py[5].FinX=475;
+  Menu_Py[5].FinY=145;
+  Menu_Py[5].Py=5;
+  Menu_Py[5].Valide=true;
+  
+  Menu_Py[6].DepX=476;
+  Menu_Py[6].DepY=70;
+  Menu_Py[6].FinX=720;
+  Menu_Py[6].FinY=145;
+  Menu_Py[6].Py=6;
+  Menu_Py[6].Valide=true;
+
+  // Boutons de musics
+  Sprites[fleches].Affiche(250,200,1,Sprites[fmenu].Image[0]);
+  Sprites[fleches].Affiche(700,200,4,Sprites[fmenu].Image[0]);
+  Menu_Py[7].DepX=230;
+  Menu_Py[7].DepY=155;
+  Menu_Py[7].FinX=475;
+  Menu_Py[7].FinY=245;
+  Menu_Py[7].Py=7;
+  Menu_Py[7].Valide=true;
+  
+  Menu_Py[8].DepX=476;
+  Menu_Py[8].DepY=155;
+  Menu_Py[8].FinX=720;
+  Menu_Py[8].FinY=245;
+  Menu_Py[8].Py=8;
+  Menu_Py[8].Valide=true;
+
+  Menu_Py[9].DepX=-1;
+
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+}
+  
+/*** Gestion du menu Options ***/
+/*******************************/
+eMenu Menu::SDLMain_Options(void)
+{
+  int i,N;
+  int NumSp;
+
+  InitMain_Options(); // Prï¿½pare le menu
+
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    return mMenu;
+	  case SDLK_LEFT:
+	    switch(PyE) {
+	    case 2:
+	      if(Pref.FullScreen==false) {
+		Pref.FullScreen=true;
+		ChangeVideo();
+		InitMain_Options();
+		PyE=2;
+	      }
+	      break;
+	    case 0:
+	    case 5: // Diminue volume sons
+	    case 6:
+	      Pref.Volume-=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.Volume<0) Pref.Volume=0;
+	      Sons.DoVolume();
+	      Sons.Play(sLive);
+	      break;
+	    case 1:
+	    case 7: // Diminue volume music
+	    case 8:
+	      Pref.VolumeM-=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.VolumeM<0) Pref.VolumeM=0;
+	      Sons.DoVolume();
+	      break;
+	    }
+	    break;
+	  case SDLK_RIGHT:
+	    switch(PyE) {
+	    case 2:
+	      if(Pref.FullScreen==true) {
+		Pref.FullScreen=false;
+		ChangeVideo();
+		InitMain_Options();
+		PyE=2;
+	      }
+	      break;
+	    case 0:
+	    case 5:
+	    case 6:
+	      Pref.Volume+=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.Volume>SDL_MIX_MAXVOLUME) Pref.Volume=SDL_MIX_MAXVOLUME;
+	      Sons.DoVolume();
+	      Sons.Play(sLive);
+	      break;
+	    case 1:
+	    case 7:
+       	    case 8:
+	      Pref.VolumeM+=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.VolumeM>SDL_MIX_MAXVOLUME) Pref.VolumeM=SDL_MIX_MAXVOLUME;
+	      Sons.DoVolume();
+	      break;
+	    }
+	    break;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0) PyE=4;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>=5) PyE=0;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    switch(PyE) {
+	    case 0:
+	    case 1:
+	      break;
+	    case 2: // Type d'affichage
+	      Pref.FullScreen=(Pref.FullScreen+1)&1;
+	      ChangeVideo();
+	      InitMain_Options();
+	      PyE=2;
+	      break;
+	    case 3: // Choix de la langue
+	      SDLMain_Langue();
+	      InitMain_Options();
+	      PyE=3;
+	      break;
+	    case 5: // Diminue volume sons
+	      Pref.Volume-=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.Volume<0) Pref.Volume=0;
+	      Sons.DoVolume();
+	      Sons.Play(sLive);
+	      break;
+	    case 6:
+	      Pref.Volume+=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.Volume>SDL_MIX_MAXVOLUME) Pref.Volume=SDL_MIX_MAXVOLUME;
+	      Sons.DoVolume();
+	      Sons.Play(sLive);
+	      break;
+	    case 7: // Diminue volume music
+	      Pref.VolumeM-=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.VolumeM<0) Pref.VolumeM=0;
+	      Sons.DoVolume();
+	      break;
+	    case 8:
+	      Pref.VolumeM+=SDL_MIX_MAXVOLUME/10.0;
+	      if(Pref.VolumeM>SDL_MIX_MAXVOLUME) Pref.VolumeM=SDL_MIX_MAXVOLUME;
+	      Sons.DoVolume();
+	      break;
+	    default:
+	      return mMenu;
+	    }
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+
+    if(Pref.FullScreen) {
+      Ec[NumEc].Affiche(fleches,1,350,300);
+      Ec[NumEc].Affiche(fleches,3,450,300);
+    }
+    else {
+      Ec[NumEc].Affiche(fleches,0,350,300);
+      Ec[NumEc].Affiche(fleches,4,450,300);
+    }
+
+    NumSp=(Horloge/30)%25;
+    Ec[NumEc].Affiche(bruitage,NumSp,150,110);
+    NumSp=(Horloge/30)%25;
+    Ec[NumEc].Affiche(music,NumSp,150,200);
+    NumSp=(Horloge/50)%50;
+    Ec[NumEc].Affiche(monde,NumSp,180,400);
+
+    N=(int)(Pref.Volume*10+1)/SDL_MIX_MAXVOLUME;
+    NumSp=(Horloge/50)%40+120;
+    for(i=0;i<N;i++) {
+      if(i==N-1) Ec[NumEc].Affiche(locomotive,NumSp,(690-300)/10*i+300,110);
+      else Ec[NumEc].Affiche(buches,NumSp,(690-300)/10*i+300,110);
+    }
+
+    N=(int)(Pref.VolumeM*10+1)/SDL_MIX_MAXVOLUME;
+    for(i=0;i<N;i++) {
+      if(i==N-1) Ec[NumEc].Affiche(locomotive,NumSp,(690-300)/10*i+300,200);
+      else Ec[NumEc].Affiche(buches,NumSp,(690-300)/10*i+300,200);
+    }
+
+    switch(PyE) {
+    case 3:
+      Affiche_Main(180);
+      break;
+    case 4:
+      Affiche_Main(CentreM);
+      break;
+    case 5:
+      PyE=0;
+      Affiche_Main();
+      PyE=5;
+      break;
+    case 6:
+      PyE=0;
+      Affiche_Main();
+      PyE=6;
+      break;
+    case 7:
+      PyE=1;
+      Affiche_Main();
+      PyE=7;
+      break;
+    case 8:
+      PyE=1;
+      Affiche_Main();
+      PyE=8;
+      break;
+    default:
+      Affiche_Main();
+    }
+    
+    Sourie.Affiche(NumEc);
+    
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** SDL Main Menu Choix de la difficultï¿½ ***/
+/********************************************/
+eMenu Menu::SDLMain_Speed(void)
+{
+  // Initialisations Divers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=1;
+  
+  // Prend l'image du fond et fait l'affichage 
+  Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  Sprites[menu].Affiche(400,340,0,Sprites[fmenu].Image[0]);
+  Sprites[titre].Affiche(400,65,0,Sprites[fmenu].Image[0]);
+
+  AfficheText(400,225,T_easy,Sprites[fmenu].Image[0]);
+  AddBouton(0,T_easy,400,225);
+  AfficheText(400,340,T_normal,Sprites[fmenu].Image[0]);
+  AddBouton(1,T_normal,400,340);
+  AfficheText(400,455,T_hard,Sprites[fmenu].Image[0]);
+  AddBouton(2,T_hard,400,455);
+  Menu_Py[3].DepX=-1;
+
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    return mMenu;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0) PyE=2;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>2) PyE=0;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    switch(PyE) {
+	    case 0:
+	      Pref.Difficulte=Easy;
+	      return mJeux;
+	    case 1:
+	      Pref.Difficulte=Normal;
+	      return mJeux;
+	    case 2:
+	      Pref.Difficulte=Hard;
+	      return mJeux;
+	    }
+	    break;
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+    Affiche_Main();
+    Sourie.Affiche(NumEc);
+    
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** SDL Main Menu Choix du niveau ***/
+/*************************************/
+eMenu Menu::SDLMain_Niveau(void)
+{
+  // Initialisations Divers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=0;
+  Niv=Pref.NiveauMax;
+  Pref.Niveau=0;
+
+  if(Niv==0) return mMenuSpeed; // Inutile si la premiï¿½re fois
+
+  // Prend l'image du fond et fait l'affichage 
+  Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  Sprites[menu].Affiche(400,340,0,Sprites[fmenu].Image[0]);
+  Sprites[titre].Affiche(400,65,0,Sprites[fmenu].Image[0]);
+
+  AfficheText(400,225,T_new_game,Sprites[fmenu].Image[0]);
+  AddBouton(0,T_new_game,400,225);
+  AfficheText(400,320,T_old_level,Sprites[fmenu].Image[0]);
+  AddBouton(1,T_old_level,400,320);
+  AfficheText(400,455,T_menu,Sprites[fmenu].Image[0]);
+  AddBouton(2,T_menu,400,455);
+  
+  AddBouton(3,fleches,330,380);
+  AddBouton(4,fleches,470,380);
+
+  Menu_Py[5].DepX=-1;
+  
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    return mMenu;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0 || PyE>2) PyE=2;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>2) PyE=0;
+	    break;
+	  case SDLK_LEFT:
+	    if(Niv>0) Niv--;
+	    PyE=1;
+	    break;
+	  case SDLK_RIGHT:
+	    if(Niv<Pref.NiveauMax) Niv++;
+	    PyE=1;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    switch(PyE) {
+	    case 0:
+	      return mMenuSpeed;
+	    case 1:
+	      Pref.Niveau=Niv;
+	      return mMenuSpeed;
+	    case 2:
+	      return mMenu;
+	    case 3:
+	      if(Niv>0) Niv--;
+	      break;
+	    case 4:
+	      if(Niv<Pref.NiveauMax) Niv++;
+	      break;
+	    }
+	    break;
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+    EffaceChiffre(400,380,999,Sprites[fmenu].Image[0]);
+
+    // Affiche les flï¿½ches
+    if(Niv>0) {
+      if(PyE==3) Ec[NumEc].Affiche(fleches,2,330,380);
+      else Ec[NumEc].Affiche(fleches,1,330,380);
+    }
+    else Ec[NumEc].Affiche(fleches,0,330,380);
+    
+    if(Niv<Pref.NiveauMax) {
+      if(PyE==4) Ec[NumEc].Affiche(fleches,5,470,380);
+      else Ec[NumEc].Affiche(fleches,4,470,380);
+    }
+    else Ec[NumEc].Affiche(fleches,3,470,380);
+    
+    AfficheChiffre(400,380,Niv+1);
+    
+    if(PyE!=3 && PyE!=4) Affiche_Main();
+    Sourie.Affiche(NumEc);
+    
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** SDL Main questions sur les droits de l'homme ***/
+/****************************************************/
+#ifndef DCHILDREN
+eMenu Menu::SDLMain_HR(void)
+{
+  int Fini=-1;
+  int N1,N2,Ordre;
+  SDL_Rect Position;
+
+  // InitialisationsDivers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=rand()%2;
+  
+  // Choix de la question N1=reponse
+  N1=rand()%30;
+  do {
+    N2=rand()%30;
+  } while (N2==N1);
+  Ordre=rand()%2; // Si 0=bonne ordre, 1=inverse
+
+  // Prend l'image du fond et fait l'affichage
+  Position.x=Position.y=0;
+  Position.w=Sprites[fmenu].Dim[0].L;
+  Position.h=Sprites[fmenu].Dim[0].H;
+  SDL_BlitSurface(sdlVideo,&Position,Sprites[fmenu].Image[0],&Position);
+  
+  Sprites[menu].Affiche(340,300,0,Sprites[fmenu].Image[0]);
+  Sprites[fond_hr].Affiche(340,74,0,Sprites[fmenu].Image[0]);
+  AfficheText(338,70,e_Sprite(T_question),Sprites[fmenu].Image[0]);
+
+  Sprites[locomotive].Affiche(115,110,rand()%320,Sprites[fmenu].Image[0]);
+  Sprites[deco].Affiche(100,160+(rand()%130),rand()%18,Sprites[fmenu].Image[0]);
+  Sprites[deco].Affiche(100,470-(rand()%130),rand()%18,Sprites[fmenu].Image[0]);
+  Sprites[deco].Affiche(580,100+(rand()%130),rand()%18,Sprites[fmenu].Image[0]);
+  Sprites[deco].Affiche(580,470-(rand()%130),rand()%18,Sprites[fmenu].Image[0]);
+
+  AfficheText(340,300,e_Sprite(T_art1+N1),Sprites[fmenu].Image[0]);
+
+  if(Ordre) {
+    AddBouton(0,e_Sprite(T_tart1+N1),240,492);
+    AddBouton(1,e_Sprite(T_tart1+N2),440,492);
+  }
+  else {
+    AddBouton(0,e_Sprite(T_tart1+N1),440,492);
+    AddBouton(1,e_Sprite(T_tart1+N2),240,492);
+  }
+  Menu_Py[0].DepY-=20;
+  Menu_Py[0].FinY+=20;
+  Menu_Py[1].DepY-=20;
+  Menu_Py[1].FinY+=20;
+
+  Menu_Py[2].DepX=-1;
+
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(Fini==-1 && event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    return mJeux;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0) PyE=1;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>1) PyE=0;
+	    break;
+	  case SDLK_LEFT:
+	    if(Ordre) PyE=0;
+	    else PyE=1;
+	    break;
+	  case SDLK_RIGHT:
+	    if(Ordre) PyE=1;
+	    else PyE=0;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    switch(PyE) {
+	    case 0:
+	      Sons.Play(sEnd);
+	      Pref.Score+=50;
+	      Fini=Horloge+2000;
+	      break;
+	    case 1:
+	      Sons.Play(sLose);
+	      Fini=Horloge+2000;
+	      break;
+	    }
+	    break;
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+
+    // Test si fini
+    if(Fini!=-1 && Fini<Horloge) return mJeux;
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+  
+    if(Ordre) {
+      Ec[NumEc].Affiche(fond_hrr,0,240,492);
+      AfficheText(240,492,e_Sprite(T_tart1+N1));
+    }
+    else {
+      Ec[NumEc].Affiche(fond_hrr,0,440,492);
+      AfficheText(440,492,e_Sprite(T_tart1+N1));
+    }
+    
+    if(Fini==-1) {
+      if(Ordre) {
+	Ec[NumEc].Affiche(fond_hrr,0,440,492);
+	AfficheText(440,492,e_Sprite(T_tart1+N2));
+	if(PyE==0) Affiche_Main(240);
+	else Affiche_Main(440);
+      }
+      else {
+	Ec[NumEc].Affiche(fond_hrr,0,240,492);
+	AfficheText(240,492,e_Sprite(T_tart1+N2));
+	if(PyE==1) Affiche_Main(240);
+	else Affiche_Main(440);
+      }      
+      Sourie.Affiche(NumEc);
+    }
+    
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+
+  return mQuit;
+}
+#endif
+
+/*** SDL Main dans la partie ***/
+/*******************************/
+void Menu::Affiche_InGame(void)
+{
+  SDL_Rect Position;
+  
+  // InitialisationsDivers
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  PyE=0;
+  
+  // Prend l'image du fond et fait l'affichage
+  Position.x=Position.y=0;
+  Position.w=Sprites[fmenu].Dim[0].L;
+  Position.h=Sprites[fmenu].Dim[0].H;
+  SDL_BlitSurface(sdlVideo,&Position,Sprites[fmenu].Image[0],&Position);
+  
+  Sprites[menu].Affiche(340,300,0,Sprites[fmenu].Image[0]);
+
+  AfficheText(340,185,T_continue,Sprites[fmenu].Image[0]);
+  AddBouton(0,T_continue,340,185);
+  AfficheText(340,300,T_moptions,Sprites[fmenu].Image[0]);
+  AddBouton(1,T_moptions,340,300);
+  AfficheText(340,415,T_exit_game,Sprites[fmenu].Image[0]);
+  AddBouton(2,T_exit_game,340,415);
+  Menu_Py[3].DepX=-1;
+
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+}
+
+/*** Gestion du menu dans le jeu ***/
+/***********************************/
+eMenu Menu::SDLMain_InGame(void)
+{
+  Affiche_InGame();
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN:
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  switch(event.key.keysym.sym) {
+	  case SDLK_ESCAPE:
+	    return mJeux;
+	  case SDLK_UP:
+	    PyE--;
+	    if(PyE<0) PyE=2;
+	    break;
+	  case SDLK_DOWN:
+	    PyE++;
+	    if(PyE>2) PyE=0;
+	    break;
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;    
+	  case ' ':
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    switch(PyE) {
+	    case 0:
+	      return mJeux;
+	    case 1:
+	      SDLMain_Options();
+	      Affiche_InGame();
+	      PyE=1;
+	      break;
+	    case 2:
+	      return mScoreEdit;
+	    }
+	    break;
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+	break;
+      }
+    }
+    
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+    Affiche_Main(340);
+    Sourie.Affiche(NumEc);
+    
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** SDL Main Menu Choix de la difficultï¿½ ***/
+/********************************************/
+eMenu Menu::SDLMain_Score(bool EditScore)
+{
+  int i;
+  int NEdit=-1;
+  char Provi[256];
+  int PosCur=0;
+  char key;
+
+  // Cherche le numï¿½ro du score ï¿½ remplacer si edition des scores
+  if(EditScore) {
+    for(i=7;i>=0;i--) if(Pref.Sco[i].Score<Pref.Score) NEdit=i;
+    if(NEdit==-1) return mMenu;
+
+    if(NEdit<7) // Si doit fair un dï¿½calage
+      for(i=7;i>NEdit;i--) {
+	Pref.Sco[i].Score=Pref.Sco[i-1].Score;
+	strcpy(Pref.Sco[i].Name,Pref.Sco[i-1].Name);
+      }
+
+    // Efface le nouveau nom et met le score
+    Pref.Sco[NEdit].Score=Pref.Score;
+    Pref.Sco[NEdit].Name[0]=0;
+  }
+  
+  // Met la sourie sur tous l'ecran
+  Sourie.Init(Menu_Py); // Initialise la sourie
+  Menu_Py[0].DepX=0;
+  Menu_Py[0].DepY=0;
+  Menu_Py[0].FinX=800;
+  Menu_Py[0].FinY=600;
+  Menu_Py[0].Py=0;
+  Menu_Py[0].Valide=true;
+  Menu_Py[1].DepX=-1;
+  
+  // Prend l'image du fond et fait l'affichage 
+  Sprites[fond_menu].Affiche(400,300,0,Sprites[fmenu].Image[0]);
+  
+  // Affiche le titre et les commandes
+  AfficheText(400,50,T_better_scores,Sprites[fmenu].Image[0]);
+  AfficheText(400,550,T_press_any_key,Sprites[fmenu].Image[0]);
+
+  // Affiche les scores
+  for(i=0;i<8;i++) {
+    sprintf(Provi,"%u",i+1);
+    AfficheString(70,120+i*(360/7),Provi,Sprites[fmenu].Image[0]);
+
+    if(EditScore==false || NEdit!=i) {
+      if(Pref.Sco[i].Name[0]) AfficheString(140,120+i*(360/7),Pref.Sco[i].Name,Sprites[fmenu].Image[0]);
+      else AfficheString(140,120+i*(360/7),Points,Sprites[fmenu].Image[0]);
+    }
+    
+    sprintf(Provi,"%i",Pref.Sco[i].Score);
+    AfficheString(740-LongueurString(Provi),120+i*(360/7),Provi,Sprites[fmenu].Image[0]);
+  }
+  
+  // Efface le fond
+  NumEc=0;
+  Ec[1].Cls(fmenu);
+  SDL_Flip(sdlVideo);
+  Ec[0].Cls(fmenu);
+  
+  // Prend les evenements
+  do {
+    SDL_Event event;
+    while(SDL_PollEvent(&event)) {
+      Sourie.GetEvent(event,PyE); // Prend les evenements de la sourie
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	if(event.active.gain==1) {
+	  NumEc=0;
+	  Ec[1].Cls(fmenu);
+	  SDL_Flip(sdlVideo);
+	  Ec[0].Cls(fmenu);
+	}
+	break;
+      case SDL_KEYDOWN: // Prend un touche au clavier
+	if(event.key.state==SDL_PRESSED) {
+	  Sons.Play(sClic);
+	  if(EditScore==false && event.key.keysym.sym!=SDLK_F12) event.key.keysym.sym=SDLK_RETURN;
+	  switch(event.key.keysym.sym) {
+	  case SDLK_F12: // Sauve un screenshot
+	    SDL_SaveBMP(sdlVideo,"screenshot.bmp");
+	    break;   
+	  case SDLK_ESCAPE: // Valide l'entrï¿½e
+	  case SDLK_RETURN:
+	  case SDLK_KP_ENTER:
+	    return mMenu;
+	  case SDLK_BACKSPACE: // Fait un retour de chariot
+	    if(PosCur) {
+	      PosCur--;
+	      Pref.Sco[NEdit].Name[PosCur]=0;
+	    }
+	    break;
+	  default: // Prend les touches
+	    key=event.key.keysym.unicode&0x7F; // Prend le caracataire correspondant ï¿½ la touche
+	    if(PosCur<79 && CharExiste(key)==true) { // Prend le caractaire
+	      Pref.Sco[NEdit].Name[PosCur]=key;
+	      Pref.Sco[NEdit].Name[PosCur+1]=0;
+	      if(LongueurString(Pref.Sco[NEdit].Name)<LSCOREMAX) { // Si longueur encore Ok
+		PosCur++;
+	      }
+	      else {
+		Pref.Sco[NEdit].Name[PosCur]=0; // Ne valide pas le caracataire
+	      }
+	    }
+	    break;
+	  }
+	}
+	break;
+      case SDL_QUIT:
+	return mQuit;
+      }
+    }
+
+    // Gï¿½re les variables
+    HorlogeAvant=Horloge;
+    Horloge=SDL_GetTicks();
+    Sleeping();
+    
+    // Gï¿½re l'Affichage
+    Ec[NumEc].Efface(fmenu);
+
+    if(EditScore) { // Gï¿½re l'affiche pour l'ï¿½dition des scores
+      Sprites[fmenu].EffaceCarre(140,120-360/14+NEdit*(360/7),140+LSCOREMAX,120-360/14+(NEdit+1)*(360/7),
+				 Sprites[fmenu].Image[0]);
+      AfficheString(140,120+NEdit*(360/7),Pref.Sco[NEdit].Name);
+      
+      i=(Horloge/50)%20; // Affiche les curseurs
+      Ec[NumEc].Affiche(fleche_gauche,i,110,120+NEdit*(360/7));
+      Ec[NumEc].Affiche(fleche_droite,i,180+LongueurString(Pref.Sco[NEdit].Name),120+NEdit*(360/7));
+
+    }
+  
+    // Echange les buffets video
+    SDL_Flip(sdlVideo);
+    NumEc=(NumEc+1)&1;
+    
+  } while(true);
+  
+  return mQuit;
+}
+
+/*** Affiche le menu Principale ***/
+/**********************************/
+void Menu::Affiche_Main(int Centre)
+{
+  int NumSp=(Horloge/50)%20;
+  int x1=Menu_Py[PyE].DepX-25;
+  int x2=(Centre-x1)+Centre;
+  int y=(Menu_Py[PyE].FinY+Menu_Py[PyE].DepY)/2;
+  
+  Ec[NumEc].Affiche(fleche_gauche,NumSp,x1,y);
+  Ec[NumEc].Affiche(fleche_droite,NumSp,x2,y);
+}
+
+/*** Centre les flï¿½ches sur le boutton ***/
+/*****************************************/
+void Menu::Affiche_Main_Centre()
+{
+  int NumSp=(Horloge/50)%20;
+  int x1=Menu_Py[PyE].DepX-5;
+  int x2=Menu_Py[PyE].FinX+5;
+  int y=(Menu_Py[PyE].FinY+Menu_Py[PyE].DepY)/2;
+  
+  Ec[NumEc].Affiche(fleche_gauche,NumSp,x1,y);
+  Ec[NumEc].Affiche(fleche_droite,NumSp,x2,y);
+}
diff -Naur Ri-li-2.0.1.orig/src/mouse.cc Ri-li-2.0.1/src/mouse.cc
--- Ri-li-2.0.1.orig/src/mouse.cc	2007-11-02 13:48:20.000000000 +0200
+++ Ri-li-2.0.1/src/mouse.cc	2008-05-11 09:50:55.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Class de la Sourie
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,7 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 #include "mouse.h"
 #include "preference.h"
@@ -50,7 +50,7 @@
 /****************************/
 void Mouse::InitStart(void) 
 {
-  // Initialise les coordonnées de la sourie
+  // Initialise les coordonnï¿½es de la sourie
   Px=400;
   Py=300;
   SDL_WarpMouse(Px,Py);
@@ -78,7 +78,7 @@
     // regarde si doit bouger la position de Py
     if(tPy) { // Si bien une table
       i=0;
-      while(tPy[i].DepX!=-1) { // Fait toutes les coordonnées
+      while(tPy[i].DepX!=-1) { // Fait toutes les coordonnï¿½es
 	if(Px>=tPy[i].DepX && Px<=tPy[i].FinX && Py>=tPy[i].DepY && Py<=tPy[i].FinY) 
 	  if(pPy!=tPy[i].Py) {
 	    pPy=tPy[i].Py;
@@ -96,7 +96,7 @@
       // regarde si doit valider un enter
       if(tPy) { // Si bien une table
 	i=0;
-	while(tPy[i].DepX!=-1) { // Fait toutes les coordonnées
+	while(tPy[i].DepX!=-1) { // Fait toutes les coordonnï¿½es
 	  if(Px>=tPy[i].DepX && Px<=tPy[i].FinX && Py>=tPy[i].DepY && Py<=tPy[i].FinY) 
 	    if(tPy[i].Valide==true) {
 	      event.type=SDL_KEYDOWN;
@@ -110,7 +110,7 @@
       // Fait la gestion des bouttons
       if(Bo) { // Si bien une table
 	i=0;
-	while(Bo[i].DepX!=-1) { // Fait toutes les coordonnées
+	while(Bo[i].DepX!=-1) { // Fait toutes les coordonnï¿½es
 	  if(Px>=Bo[i].DepX && Px<=Bo[i].FinX && Py>=Bo[i].DepY && Py<=Bo[i].FinY) {
 	    if(Bo[i].Adr==NULL) { // Si doit fair une touche
 	      event.type=SDL_KEYDOWN;
@@ -137,7 +137,7 @@
   int X=Px,Y=Py;
   int NumSp=(Horloge/50)%20;
   
-  // Corrige la position du curseur au cas ou déborde de l'écran
+  // Corrige la position du curseur au cas ou dï¿½borde de l'ï¿½cran
   if(X<5) X=5;
   if(X>=800-38) X=800-39;
   if(Y<10) Y=10;
diff -Naur Ri-li-2.0.1.orig/src/sprite.cc Ri-li-2.0.1/src/sprite.cc
--- Ri-li-2.0.1.orig/src/sprite.cc	2007-11-02 13:48:20.000000000 +0200
+++ Ri-li-2.0.1/src/sprite.cc	2008-05-11 10:01:55.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Sprite
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,9 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
+using namespace std;
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -43,7 +45,7 @@
 static char* OrdreTexte2="abcdefghijklmnopqrstuvwxyz0123456789,_|?*+<>%$[]&;";
 static int TableTexte[256]; 
 
-char Langue[31][16]; // Mémorise les noms des langues
+char Langue[31][16]; // Mï¿½morise les noms des langues
 int NTextes=0;
 bool AfficheC=false; // Si peut afficher le chargeur lors du chargement
 
@@ -53,13 +55,13 @@
 /**********************************************/
 void AfficheChargeur()
 {
-  static int NumAf=-1; // Numéro su sprite affiché
+  static int NumAf=-1; // Numï¿½ro su sprite affichï¿½
   int i,Old;
   int Hor;
 
   if(AfficheC==true) {
     Hor=SDL_GetTicks();
-    i=(Hor/(1000/25))%Sprites[chargeur].N; // Calcule le numéro su sprite à afficher
+    i=(Hor/(1000/25))%Sprites[chargeur].N; // Calcule le numï¿½ro su sprite ï¿½ afficher
 
     if(i!=NumAf) {
       Old=NumAf;
@@ -95,7 +97,7 @@
     if(Sprites[T_level+i].N) Sprites[T_level+i].Delete();
     if(Sprites[T_level+i].Load(Buf,P)==false) return false;
   }
-  delete [] Buf; // Libère la mémoire du fichier des sprites
+  delete [] Buf; // Libï¿½re la mï¿½moire du fichier des sprites
 
   return true;
 }
@@ -142,7 +144,7 @@
   NSprites=NSp+NTextes+Pref.NLangues;
   Sprites=new Sprite[NSprites];
 
-  // Récupère les nom des langues
+  // Rï¿½cupï¿½re les nom des langues
   P=6;
   for(i=0;i<Pref.NLangues;i++) {
     strcpy(Langue[i],(char*)(Buf+P));
@@ -187,7 +189,7 @@
     }
   }
   
-  delete [] Buf; // Libère la mémoire du fichier des sprites
+  delete [] Buf; // Libï¿½re la mï¿½moire du fichier des sprites
   
   // *** Charge la langue ***
   // ************************
@@ -352,7 +354,7 @@
     Image[i]=SDL_CreateRGBSurface((Dim[i].bpp-3)*SDL_SRCALPHA,Dim[i].L,Dim[i].H,Dim[i].bpp*8,
 				  0xff,0xff00,0xff0000,0xff000000*(Dim[i].bpp-3));
     if(Image[i]<=NULL) {
-      cerr <<"Impossible de créer une Surface SDL!"<<endl;
+      cerr <<"Impossible de crï¿½er une Surface SDL!"<<endl;
       return false;
     }
     
@@ -449,7 +451,7 @@
   SDL_BlitSurface(Fond,&Position,sdlVideo,&Position);
 }
 
-/*** Efface un carré à l'ecran ***/
+/*** Efface un carrï¿½ ï¿½ l'ecran ***/
 /*********************************/
 void Sprite::EffaceCarre(int dx,int dy,int fx,int fy,SDL_Surface *Fond)
 {
@@ -486,7 +488,7 @@
   Image[0]=SDL_CreateRGBSurface((Dim[0].bpp-3)*SDL_SRCALPHA,Dim[0].L,Dim[0].H,Dim[0].bpp*8,
 				0xff,0xff00,0xff0000,0xff000000*(Dim[0].bpp-3));
   if(Image[0]<=NULL) {
-    cerr <<"Impossible de créer une Surface SDL!"<<endl;
+    cerr <<"Impossible de crï¿½er une Surface SDL!"<<endl;
     return false;
   }
   return true;
diff -Naur Ri-li-2.0.1.orig/src/sprite.cc~ Ri-li-2.0.1/src/sprite.cc~
--- Ri-li-2.0.1.orig/src/sprite.cc~	1970-01-01 02:00:00.000000000 +0200
+++ Ri-li-2.0.1/src/sprite.cc~	2008-05-11 09:51:03.000000000 +0300
@@ -0,0 +1,507 @@
+//      (_||_/
+//      (    )       Classe Sprite
+//     ( o  0 )
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
+//                   Copyright (C) 2006 By Dominique Roux-Serret
+// .OOOo      oOOO.  roux-serret@ifrance.com
+//-(   )------(   )---------------------------------------
+//  ( (        ) /   Le 11/01/2006
+//   (_)      (_/
+
+//    This program is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 or version 3 of the License.
+
+//    This program is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+
+//    You should have received a copy of the GNU General Public License along
+//    with this program; if not, write to the Free Software Foundation, Inc.,
+//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include "sprite.h"
+#include "preference.h"
+#include "utils.h"
+
+/*** Variables Globales ***/
+/**************************/
+extern SDL_Surface *sdlVideo;
+extern SDL_VideoInfo *sdlVideoInfo;
+extern Uint32 FontColor;
+extern Sprite *Sprites;
+extern int NSprites;
+extern sPreference Pref;
+
+static char* OrdreTexte="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-!?*+<>%$()&;";
+static char* OrdreTexte2="abcdefghijklmnopqrstuvwxyz0123456789,_|?*+<>%$[]&;";
+static int TableTexte[256]; 
+
+char Langue[31][16]; // Mï¿½morise les noms des langues
+int NTextes=0;
+bool AfficheC=false; // Si peut afficher le chargeur lors du chargement
+
+#define N_SPRITESFOND 2
+
+/*** Affiche le chargeur lors du chargement ***/
+/**********************************************/
+void AfficheChargeur()
+{
+  static int NumAf=-1; // Numï¿½ro su sprite affichï¿½
+  int i,Old;
+  int Hor;
+
+  if(AfficheC==true) {
+    Hor=SDL_GetTicks();
+    i=(Hor/(1000/25))%Sprites[chargeur].N; // Calcule le numï¿½ro su sprite ï¿½ afficher
+
+    if(i!=NumAf) {
+      Old=NumAf;
+      NumAf=i;
+      Sprites[chargeur].Affiche(400,300,NumAf);
+      SDL_Flip(sdlVideo);
+      if(Old!=-1) Sprites[chargeur].Efface(400,300,Old,sdlVideo);
+    }
+  }
+  
+}
+
+/*** Charge les Sprites d'une langue ***/
+/***************************************/
+bool LoadLangue()
+{
+  long L,P;
+  int i;
+  unsigned char *Buf;
+  char PathFile[512];
+
+  strcpy(PathFile,Langue[Pref.Langue]);
+  GetPath(PathFile);
+  if(FileExiste(PathFile)==false) {
+    cerr <<"Impossible de trouver "<<Langue[Pref.Langue]<<endl;
+    return false;
+  }
+  L=ChargeFichier(PathFile,Buf);
+
+  // Lit les sprites
+  P=0;
+  for(i=0;i<NTextes;i++) {
+    if(Sprites[T_level+i].N) Sprites[T_level+i].Delete();
+    if(Sprites[T_level+i].Load(Buf,P)==false) return false;
+  }
+  delete [] Buf; // Libï¿½re la mï¿½moire du fichier des sprites
+
+  return true;
+}
+
+/*** Charge les Sprites du jeu ***/
+/*********************************/
+bool LoadSprites()
+{
+  long L,P;
+  int i;
+  unsigned char *Buf;
+  int NSp;
+
+  char PathFile[512]="language.dat";
+  GetPath(PathFile);
+
+  // Initialise la table de caractaire des textes
+  for(i=0;i<256;i++) TableTexte[i]=-1;
+  i=0;
+  while(OrdreTexte[i]!=0) {
+    TableTexte[(int)(OrdreTexte[i])]=i;
+    i++;
+  }
+  i=0;
+  while(OrdreTexte2[i]!=0) {
+    TableTexte[(int)(OrdreTexte2[i])]=i;
+    i++;
+  }
+  
+  // *** Charge le fichier des langues ***
+  // *************************************
+  if(FileExiste(PathFile)==false) {
+    cerr <<"Impossible de trouver 'language.dat'"<<endl;
+    return false;
+  }
+  L=ChargeFichier(PathFile,Buf);
+
+  // Prend le nombre de sprites
+  NSp=(int)(Buf[0])*256+(int)(Buf[1]);
+  NSp+=N_SPRITESFOND+2;
+  NTextes=(int)(Buf[2])*256+(int)(Buf[3]);
+  Pref.NLangues=(int)(Buf[4])*256+(int)(Buf[5]);
+  
+  NSprites=NSp+NTextes+Pref.NLangues;
+  Sprites=new Sprite[NSprites];
+
+  // Rï¿½cupï¿½re les nom des langues
+  P=6;
+  for(i=0;i<Pref.NLangues;i++) {
+    strcpy(Langue[i],(char*)(Buf+P));
+    P+=strlen((char*)(Buf+P))+1;
+  }
+
+  // Charge les sprites des langues
+  for(i=0;i<Pref.NLangues;i++)
+    if(Sprites[T_Langue+i].Load(Buf,P)==false) return false;
+  
+  if(Sprites[chargeur].Load(Buf,P)==false) return false; // Sprite du chargeur
+  AfficheC=true; // Peut afficher le sprite du chargeur
+
+  delete [] Buf;
+  
+  // *** Charge le fichier des sprites ***
+  // *************************************
+  strcpy(PathFile,"sprites.dat");
+  GetPath(PathFile);
+  if(FileExiste(PathFile)==false) {
+    cerr <<"Impossible de trouver 'sprites.dat'"<<endl;
+    return false;
+  }
+  L=ChargeFichier(PathFile,Buf);
+  
+  // Lit les sprites
+  P=0;
+  for(i=0;i<NSp;i++) {
+    AfficheChargeur();
+    switch(i) {
+    case fjeu:
+    case fmenu:
+      if(Sprites[i].Nouveau(800,600)==false) return false;
+      break;
+    case corde:
+      Sprites[i].N=0;
+      break;
+    case chargeur:
+      break;
+    default:
+      if(Sprites[i].Load(Buf,P)==false) return false;
+    }
+  }
+  
+  delete [] Buf; // Libï¿½re la mï¿½moire du fichier des sprites
+  
+  // *** Charge la langue ***
+  // ************************
+  if(Pref.Langue!=-1) LoadLangue();
+
+  AfficheC=false; // N'affiche plus les sprites du chargeur
+  return true;
+}
+
+/*** Retourne la longueur d'un nombre ***/
+/****************************************/
+int LongueurChiffre(int C)
+{
+  int l=0;
+  
+  do {
+    l+=Sprites[chiffres].Dim[(C%10)].L;
+    C/=10;
+    if(C) l+=ECART_ENTRE_CHIFFRE;
+  } while(C);
+  
+  return l;
+}
+
+/*** Retourne la longueur d'un texte ***/
+/***************************************/
+int LongueurString(char *Texte)
+{
+  int i=0;
+  int l=0;
+  int Le;
+
+  while(Texte[i]!=0) {
+    Le=(int)(Texte[i]);
+    if(TableTexte[Le]!=-1) {
+      l+=Sprites[lettres].Dim[(TableTexte[Le])].L;
+      if(Texte[i+1]!=0) l+=ECART_ENTRE_LETTRE;
+    }
+    else {
+      if(Le==(int)(' ')) l+=LONGUEUR_ESPACE;
+    }
+    
+    i++;
+  }
+  
+  return l;
+}
+
+/*** Test si un caracataire existe ***/
+/*************************************/
+bool CharExiste(char C)
+{
+  if(C==' ') return true;
+  if(TableTexte[(int)(C)]!=-1) return true;
+  return false;
+}
+/*** Affiche un nombre ***/
+/*************************/
+void AfficheChiffre(int x,int y,int Nombre,SDL_Surface *Fond)
+{
+  int l=LongueurChiffre(Nombre);
+  
+  x+=l/2;
+  do {
+    Sprites[chiffres].Affiche(x-(Sprites[chiffres].Dim[(Nombre%10)].L)/2,y,Nombre%10,Fond);
+    x-=Sprites[chiffres].Dim[(Nombre%10)].L+ECART_ENTRE_CHIFFRE;
+    Nombre/=10;
+  } while(Nombre);
+  
+}
+
+/*** Affiche un Texte ***/
+/************************/
+void AfficheString(int x,int y,char *Texte,SDL_Surface *Fond)
+{
+  int i=0;
+  int Le;
+  
+  while(Texte[i]!=0) {
+    Le=(int)(Texte[i]);
+    
+    if(TableTexte[Le]!=-1) { // Si un caractaire connue
+      Le=TableTexte[Le];
+      Sprites[lettres].Affiche(x+(Sprites[lettres].Dim[Le].L/2),y,Le,Fond);
+      x+=Sprites[lettres].Dim[Le].L+ECART_ENTRE_LETTRE;
+    }
+    else { // Si un espace
+      if(Le==(int)(' ')) x+=LONGUEUR_ESPACE-ECART_ENTRE_LETTRE;
+    }
+    
+    i++;
+  }
+}
+
+/*** Efface un nombre ***/
+/************************/
+void EffaceChiffre(int x,int y,int Nombre,SDL_Surface *Fond)
+{
+  int l=LongueurChiffre(Nombre);
+  int h=Sprites[chiffres].Dim[0].H;
+
+  if(!Fond) Fond=Sprites[fjeu].Image[0];
+  Sprites[chiffres].EffaceCarre(x-l/2,y-h/2,x+l/2,y+h/2,Fond);
+}
+
+/*** Affiche un text dans la langue ***/
+/**************************************/
+void AfficheText(int x,int y,e_Sprite Text,SDL_Surface *Fond)
+{
+  Sprites[Text].Affiche(x,y,0,Fond);
+}
+
+/*** Constructeur ***/
+/********************/
+Sprite::Sprite(void) : N(0), Image(NULL), Dim(NULL)
+{ }
+
+Sprite::~Sprite(void)
+{
+  if(N) {
+    for(int i=0;i<N;i++) {
+      SDL_FreeSurface(Image[i]);
+    }
+    delete [] Image;
+    delete [] Dim;
+  }
+}
+
+/*** Charge les sprites ***/
+/**************************/
+bool Sprite::Load(unsigned char *Buf,long &P)
+{
+  int i,j;
+  unsigned char *B;
+  unsigned long ul=1; // test le type de processeur
+  unsigned char *pul=(unsigned char*)(&ul) ;
+
+  // Prend nombre de sprites
+  N=(int)(Buf[P])*256+(int)(Buf[P+1]);
+  P+=2;
+  Dim=new s_Dim[N];
+  Image=new SDL_Surface* [N];
+
+  // Lit tous les sprites
+  for(i=0;i<N;i++) {
+    // Affiche l'animation de chargement
+    AfficheChargeur();
+
+    // Lit les dimensions
+    Dim[i].L=(int)(Buf[P])*256+(int)(Buf[P+1]);
+    P+=2;
+    Dim[i].H=(int)(Buf[P])*256+(int)(Buf[P+1]);
+    P+=2;
+    Dim[i].cx=(int)(Buf[P])*256+(int)(Buf[P+1]);
+    P+=2;
+    Dim[i].cy=(int)(Buf[P])*256+(int)(Buf[P+1]);
+    P+=2;
+    Dim[i].bpp=(int)(Buf[P])*256+(int)(Buf[P+1]);
+    P+=2;
+    
+    // Fabrique la surface
+    Image[i]=SDL_CreateRGBSurface((Dim[i].bpp-3)*SDL_SRCALPHA,Dim[i].L,Dim[i].H,Dim[i].bpp*8,
+				  0xff,0xff00,0xff0000,0xff000000*(Dim[i].bpp-3));
+    if(Image[i]<=NULL) {
+      cerr <<"Impossible de crï¿½er une Surface SDL!"<<endl;
+      return false;
+    }
+    
+    // Copie les pixels
+    SDL_LockSurface(Image[i]);
+    B=(unsigned char*)Image[i]->pixels;
+    
+    if(pul[0]==0) { // Processeur type Power PC, 68000, ..
+      for(j=0;j<Dim[i].L*Dim[i].H*Dim[i].bpp;j+=Dim[i].bpp) {
+	if(Dim[i].bpp==4) B[j+3]=Buf[P++];
+	B[j+2]=Buf[P++];
+	B[j+1]=Buf[P++];
+	B[j]=Buf[P++];
+      }
+    }
+    else
+      for(j=0;j<Dim[i].L*Dim[i].H*Dim[i].bpp;j++) B[j]=Buf[P++];
+    
+    SDL_UnlockSurface(Image[i]);
+    
+    // Si peut la mettre en surface Hardware
+    if(sdlVideoInfo->blit_hw_A) {
+      SDL_Surface *Provi=SDL_ConvertSurface(Image[i],Image[i]->format,SDL_HWSURFACE);
+      SDL_FreeSurface(Image[i]);
+      Image[i]=Provi;
+    }
+  }
+  
+  return true;
+}
+
+/*** Affiche le sprite ***/
+/*************************/
+void Sprite::Affiche(int X,int Y,int NumSpr,SDL_Surface *Fond)
+{
+  SDL_Rect Position;
+  SDL_Rect Di;
+
+  Position.x=X-Dim[NumSpr].cx;
+  Position.y=Y-Dim[NumSpr].cy;
+  
+  Position.w=Position.h=Di.x=Di.y=0;
+  Di.w=Dim[NumSpr].L;
+  Di.h=Dim[NumSpr].H;
+  
+  if(Fond==NULL) Fond=sdlVideo;
+
+  SDL_BlitSurface(Image[NumSpr],&Di,Fond,&Position);
+}
+
+/*** Affiche un bout du sprite ***/
+/*********************************/
+void Sprite::AfficheCorde(int dx,int dy,int fx,int fy)
+{
+  float d;
+  float lx=float(fx-dx);
+  float ly=float(fy-dy);
+  int P,n,i,j;
+  unsigned char *B;
+  float x=dx;
+  float y=dy;
+
+  d=sqrt(lx*lx+ly*ly); // Longueur de la corde
+  if( (float)((int)(d))!=d ) n=(int)(d)+1; // Met en nombre de point
+  else n=(int)d;
+  
+  // Trace la ligne
+  SDL_LockSurface(sdlVideo);
+  B=(unsigned char*)sdlVideo->pixels;
+  
+  lx=lx/(float)n;
+  ly=ly/(float)n;
+
+  for(i=0;i<=n;i++) {
+    P=((int)(x)+(int)(y)*800)*sdlVideo->format->BytesPerPixel;
+    for(j=0;j<sdlVideo->format->BytesPerPixel;j++) B[P+j]=255;
+    x+=lx;
+    y+=ly;
+  }
+
+  SDL_UnlockSurface(sdlVideo);
+}
+
+/*** Efface le sprite ***/
+/************************/
+void Sprite::Efface(int X,int Y,int NumSpr,SDL_Surface *Fond)
+{
+  SDL_Rect Position;
+  
+  Position.w=Dim[NumSpr].L;
+  Position.h=Dim[NumSpr].H;
+  Position.x=X-Dim[NumSpr].cx;
+  Position.y=Y-Dim[NumSpr].cy;
+  SDL_BlitSurface(Fond,&Position,sdlVideo,&Position);
+}
+
+/*** Efface un carrï¿½ ï¿½ l'ecran ***/
+/*********************************/
+void Sprite::EffaceCarre(int dx,int dy,int fx,int fy,SDL_Surface *Fond)
+{
+  int p;
+  SDL_Rect Position;
+  
+  if(dx>fx) { p=dx; dx=fx; fx=p; }
+  if(dy>fy) { p=dy; dy=fy; fy=p; }
+
+  Position.w=fx-dx+1;
+  Position.h=fy-dy+1;
+  Position.x=dx;
+  Position.y=dy;
+  SDL_BlitSurface(Fond,&Position,sdlVideo,&Position);
+}
+
+/*** Alloue un nouveau sprite vide ***/
+/*************************************/
+bool Sprite::Nouveau(int Lx,int Ly)
+{
+  Delete(); // Efface au cas ou
+
+  N=1;
+  Dim=new s_Dim[N];
+  Image=new SDL_Surface* [N];
+
+  Dim[0].L=Lx;
+  Dim[0].H=Ly;
+  Dim[0].cx=Lx/2;
+  Dim[0].cy=Ly/2;
+  Dim[0].bpp=3; // Pas de transparence
+     
+  // Fabrique la surface
+  Image[0]=SDL_CreateRGBSurface((Dim[0].bpp-3)*SDL_SRCALPHA,Dim[0].L,Dim[0].H,Dim[0].bpp*8,
+				0xff,0xff00,0xff0000,0xff000000*(Dim[0].bpp-3));
+  if(Image[0]<=NULL) {
+    cerr <<"Impossible de crï¿½er une Surface SDL!"<<endl;
+    return false;
+  }
+  return true;
+}
+
+/*** Efface le sprite ***/
+/************************/
+void Sprite::Delete(void)
+{
+  if(N) {
+    for(int i=0;i<N;i++) {
+      SDL_FreeSurface(Image[i]);
+    }
+    delete [] Image;
+    delete [] Dim;
+    N=0;
+  }
+}
diff -Naur Ri-li-2.0.1.orig/src/tableau.cc Ri-li-2.0.1/src/tableau.cc
--- Ri-li-2.0.1.orig/src/tableau.cc	2007-11-02 13:48:21.000000000 +0200
+++ Ri-li-2.0.1/src/tableau.cc	2008-05-11 09:51:13.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/
 //      (    )       Classe Sprite
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,7 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 #include <stdlib.h>
 #include "preference.h"
@@ -85,7 +85,7 @@
   int i,j;
   char NameLevelFile[512]="levels.dat";
   
-  // Alloue la mémoire
+  // Alloue la mï¿½moire
   Buf=new unsigned char [sizeof(s_Tableau)*N+sizeof(int)+1];
   if(Buf<=0) return false;
 
diff -Naur Ri-li-2.0.1.orig/src/utils.cc Ri-li-2.0.1/src/utils.cc
--- Ri-li-2.0.1.orig/src/utils.cc	2007-11-02 13:48:22.000000000 +0200
+++ Ri-li-2.0.1/src/utils.cc	2008-05-11 10:02:03.000000000 +0300
@@ -1,7 +1,7 @@
 //      (_||_/       Utils.cc
 //      (    )       Fonctions divers
 //     ( o  0 )
-//-OOO°--(_)---°OOO---------------------------------------
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
 //                   Copyright (C) 2006 By Dominique Roux-Serret 
 // .OOOo      oOOO.  roux-serret@ifrance.com
 //-(   )------(   )---------------------------------------
@@ -21,7 +21,9 @@
 //    with this program; if not, write to the Free Software Foundation, Inc.,
 //    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-#include <iostream.h>
+#include <iostream>
+using namespace std;
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -43,7 +45,7 @@
 extern char DefPath[]; // Chemin par defaut dans arg
 #endif
 
-/*** Définition générals ***/
+/*** Dï¿½finition gï¿½nï¿½rals ***/
 /***************************/
 #ifdef MAC_OSX
 #define MAC_LINUX
@@ -67,7 +69,7 @@
 }
 
 
-/*** Charge un fichier en Mémoire ***/
+/*** Charge un fichier en Mï¿½moire ***/
 /************************************/
 #ifdef MAC_LINUX
 // Version linux
@@ -88,7 +90,7 @@
     return -1;
   }
 
-  long L=ftell(file); // récupère la longueur
+  long L=ftell(file); // rï¿½cupï¿½re la longueur
   fseek(file,0,0);
 
   Buf=new unsigned char [L+1];
@@ -114,7 +116,7 @@
     Po+=1024;
   }
   
-  if(Compt) { // Ne fait pas le test à cause d'un bug dans windows
+  if(Compt) { // Ne fait pas le test ï¿½ cause d'un bug dans windows
     fread(Po,1,(unsigned int)Compt,file);
   }
   
@@ -208,7 +210,7 @@
 
   file=_lcreat(Path,0);
   if(!file) {
-    cerr <<"ERREUR: Impossible de créer le fichier '"<<Path<<"'"<<endl;
+    cerr <<"ERREUR: Impossible de crï¿½er le fichier '"<<Path<<"'"<<endl;
     return false;
   }
   
@@ -216,7 +218,7 @@
   _lclose(file);
 
   if(Lec!=L) {
-    cerr <<"Problème d'ecriture du fichier '"<<Path<<"' ecris="<<Lec<<" au lieux de ="<<L<<endl;
+    cerr <<"Problï¿½me d'ecriture du fichier '"<<Path<<"' ecris="<<Lec<<" au lieux de ="<<L<<endl;
     return false;
   }
 
@@ -293,7 +295,7 @@
 { }
 #endif
 
-/*** Charge les préferences ***/
+/*** Charge les prï¿½ferences ***/
 /******************************/
 bool LoadPref(void)
 {
diff -Naur Ri-li-2.0.1.orig/src/utils.cc~ Ri-li-2.0.1/src/utils.cc~
--- Ri-li-2.0.1.orig/src/utils.cc~	1970-01-01 02:00:00.000000000 +0200
+++ Ri-li-2.0.1/src/utils.cc~	2008-05-11 09:51:24.000000000 +0300
@@ -0,0 +1,364 @@
+//      (_||_/       Utils.cc
+//      (    )       Fonctions divers
+//     ( o  0 )
+//-OOOï¿½--(_)---ï¿½OOO---------------------------------------
+//                   Copyright (C) 2006 By Dominique Roux-Serret 
+// .OOOo      oOOO.  roux-serret@ifrance.com
+//-(   )------(   )---------------------------------------
+//  ( (        ) /   Le 03/01/2006
+//   (_)      (_/
+
+//    This program is free software; you can redistribute it and/or modify
+//    it under the terms of the GNU General Public License as published by
+//    the Free Software Foundation; either version 2 or version 3 of the License.
+
+//    This program is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//    GNU General Public License for more details.
+
+//    You should have received a copy of the GNU General Public License along
+//    with this program; if not, write to the Free Software Foundation, Inc.,
+//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef WINDOWS
+#include <windows.h>
+#include <windowsx.h>
+#include <commdlg.h>
+#endif
+
+#include "utils.h"
+#include "preference.h"
+#include "sprite.h"
+
+/*** Variables globales ***/
+/**************************/
+extern sPreference Pref;
+#ifdef LINUX
+extern char DefPath[]; // Chemin par defaut dans arg
+#endif
+
+/*** Dï¿½finition gï¿½nï¿½rals ***/
+/***************************/
+#ifdef MAC_OSX
+#define MAC_LINUX
+#endif
+
+#ifdef LINUX
+#define MAC_LINUX
+#endif
+
+/*** Test si un fichier exite ***/
+/********************************/
+bool FileExiste(const char *Path)
+{
+  FILE* file=fopen(Path,"r");
+
+  if(file==NULL)
+    return false;
+
+  fclose(file);
+  return true;
+}
+
+
+/*** Charge un fichier en Mï¿½moire ***/
+/************************************/
+#ifdef MAC_LINUX
+// Version linux
+long ChargeFichier(const char *Path,unsigned char *&Buf)
+{
+  FILE *file;
+
+  file=fopen(Path,"r");
+  if(!file) {
+    cerr <<"ERREUR: Impossible d'ouvrir '"<<Path<<"'"<<endl;
+    perror("fopen");
+    return -1;
+  }
+  
+  if(fseek(file,0,2)!=0) {
+    perror("fseek");
+    fclose(file);
+    return -1;
+  }
+
+  long L=ftell(file); // rï¿½cupï¿½re la longueur
+  fseek(file,0,0);
+
+  Buf=new unsigned char [L+1];
+  if(Buf==NULL) {
+    cerr <<"ERREUR: Memoire insuffisante!"<<endl;
+    fclose(file);
+    return -1;
+  }
+
+  long Compt=L;
+  unsigned char *Po=Buf;
+
+  while(Compt>1024) {
+    AfficheChargeur();
+    if( fread(Po,1,1024,file) != 1024 ) {
+      cerr <<"ERREUR de lecture du fichier '"<<Path<<"'"<<endl;
+      perror("fread");
+      fclose(file);
+      delete [] Buf;
+      return -1;
+    }
+    Compt-=1024;
+    Po+=1024;
+  }
+  
+  if(Compt) { // Ne fait pas le test ï¿½ cause d'un bug dans windows
+    fread(Po,1,(unsigned int)Compt,file);
+  }
+  
+  fclose(file);
+  return L;
+}
+#endif
+
+#ifdef WINDOWS
+// Version windows
+long ChargeFichier(const char *Path,unsigned char *&Buf)
+{
+  HFILE file;
+
+  file=_lopen(Path,OF_READ);
+  if(file==-1) {
+    cerr <<"Impossible d'ouvrir "<<Path<<endl;
+    exit(-1);
+  }
+  
+  long L=(long)_llseek(file,0,SEEK_END);
+  if(L==-1) {
+    cerr <<"Impossible de trouver la longueur du fichier"<<endl;
+    perror("lseek");
+    _lclose(file);
+    return -1;
+  }
+  _llseek(file,0,SEEK_SET);
+  
+  Buf=new unsigned char [L+1];
+  if(Buf==NULL) {
+    cerr <<"ERREUR: Memoire insuffisante!"<<endl;
+    _lclose(file);
+    return -1;
+  }
+
+  AfficheChargeur();
+  _hread(file,Buf,L); // Charge le fichier
+  _lclose(file);      // Ferme le fichier
+
+  return L;
+}
+#endif
+
+/*** Sauve un Fichier ***/
+/************************/
+#ifdef MAC_LINUX
+// Version linux
+bool SauveFichier(const char *Path,char *Buf,long L)
+{
+  FILE *file;
+  
+  file=fopen(Path,"w");
+  if(!file) {
+    cerr <<"ERREUR: Impossible d'ouvrir '"<<Path<<"'"<<endl;
+    perror("fopen");
+    return false;
+  }
+  
+  while(L>512) {
+    if( fwrite(Buf,1,512,file) != 512 ) {
+      cerr <<"ERREUR d'ecriture du fichier '"<<Path<<"'"<<endl;
+      perror("fwrite");
+      fclose(file);
+      return false;
+    }
+    L-=512;
+    Buf+=512;
+  }
+
+  if(L>0) {
+    if( fwrite(Buf,1,(size_t)L,file) != (size_t)L ) {
+      cerr <<"ERREUR d'ecriture du fichier '"<<Path<<"'"<<endl;
+      perror("fwrite");
+      fclose(file);
+      return false;
+    }
+  }
+  
+  fclose(file);
+  return true;
+}
+#endif
+
+#ifdef WINDOWS
+// Version windows
+bool SauveFichier(const char *Path,char *Buf,long L)
+{
+  HFILE file;
+  int Lec;
+
+  file=_lcreat(Path,0);
+  if(!file) {
+    cerr <<"ERREUR: Impossible de crï¿½er le fichier '"<<Path<<"'"<<endl;
+    return false;
+  }
+  
+  Lec=_hwrite(file,Buf,L);
+  _lclose(file);
+
+  if(Lec!=L) {
+    cerr <<"Problï¿½me d'ecriture du fichier '"<<Path<<"' ecris="<<Lec<<" au lieux de ="<<L<<endl;
+    return false;
+  }
+
+  return true;
+}
+#endif
+
+/*** Met le bon chemin pour charger un fichier ***/
+/*************************************************/
+#if defined(LINUX) && !defined(__AMIGAOS4__)
+// Version Linux
+void GetPath(char *Path)
+{
+  char Provi[512];
+
+  strcpy(Provi,Path);
+
+  if(DefPath[0]) {
+    sprintf(Path,"%s%s",DefPath,Provi);
+    if(FileExiste(Path)) return;
+  }
+
+  sprintf(Path,"%s/%s",DATA_DIR,Provi);
+  if(FileExiste(Path)) return;
+  sprintf(Path,"./%s",Provi);
+  if(FileExiste(Path)) return;
+  sprintf(Path,"/usr/local/share/Ri-li/%s",Provi);
+  if(FileExiste(Path)) return;
+  sprintf(Path,"/usr/share/Ri-li/%s",Provi);
+  if(FileExiste(Path)) return;
+  sprintf(Path,"/usr/share/games/Ri-li/%s",Provi);
+  if(FileExiste(Path)) return;
+  
+  cerr <<"Impossible de trouver le fichier '"<<Provi<<endl;
+  exit(-1);
+}
+#endif
+
+#ifdef __AMIGAOS4__
+// Version AmigaOS4
+void GetPath(char *Path)
+{
+  char Provi[512];
+
+  strcpy(Provi,Path);
+
+  sprintf(Path,"PROGDIR:%s",Provi);
+  if(FileExiste(Path)) return;
+  
+  cerr <<"Impossible de trouver le fichier '"<<Path<<endl;
+  exit(-1);
+}
+#endif
+
+#ifdef MAC_OSX
+// Version Mac OSX
+void GetPath(char *Path)
+{
+  char Provi[512];
+
+  strcpy(Provi,Path);
+
+  sprintf(Path,"Ri-li.app/Contents/Resources/%s",Provi);
+  if(FileExiste(Path)) return;
+  
+  cerr <<"Impossible de trouver le fichier '"<<Path<<endl;
+  exit(-1);
+}
+#endif
+
+#ifdef WINDOWS
+//  Version Windows , chemin directe
+void GetPath(char *Path)
+{ }
+#endif
+
+/*** Charge les prï¿½ferences ***/
+/******************************/
+bool LoadPref(void)
+{
+  int L;
+  unsigned char *Provi;
+  
+#if defined(LINUX) && !defined(__AMIGAOS4__)
+  char PathPref[512];
+  char *Env=getenv("HOME");
+  sprintf(PathPref,"%s/.ri-li.pref",Env);
+#elif defined(__AMIGAOS4__)
+  char PathPref[512];
+  char *Env="PROGDIR:";
+  sprintf(PathPref,"%s.ri-li.pref",Env);
+#endif
+
+#ifdef MAC_OSX
+  char PathPref[512];
+  char *Env=getenv("HOME");
+  sprintf(PathPref,"%s/Library/Preferences/Ri-li.pref",Env);
+#endif
+
+#ifdef WINDOWS
+  // Version Windows, Chemin directe
+  char *PathPref="ri-li.pref";
+#endif
+  
+  if(FileExiste(PathPref)) {
+    L=ChargeFichier(PathPref,Provi);
+    if(L>0) {
+      memcpy((char*)&Pref,Provi,L);
+      delete [] Provi;
+      return true;
+    }
+  }
+  
+  return false;
+}
+
+/*** Sauve les preferences ***/
+/*****************************/
+void SauvePref(void)
+{  
+#if defined(LINUX) && !defined(__AMIGAOS4__)
+  char Provi[512];
+  char *Env=getenv("HOME");
+  sprintf(Provi,"%s/.ri-li.pref",Env);
+  SauveFichier(Provi,(char*)&Pref,sizeof(sPreference));
+#elif defined(__AMIGAOS4__)
+  char Provi[512];
+  char *Env="PROGDIR:";
+  sprintf(Provi,"%s.ri-li.pref",Env);
+  SauveFichier(Provi,(char*)&Pref,sizeof(sPreference));
+#endif
+
+#ifdef MAC_OSX
+  char Provi[512];
+  char *Env=getenv("HOME");
+  sprintf(Provi,"%s/Library/Preferences/Ri-li.pref",Env);
+  SauveFichier(Provi,(char*)&Pref,sizeof(sPreference));
+#endif
+
+#ifdef WINDOWS
+  // Version Windows, chemin directe
+  SauveFichier("ri-li.pref",(char*)&Pref,sizeof(sPreference));
+#endif
+}
+
