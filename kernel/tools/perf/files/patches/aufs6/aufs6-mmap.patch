SPDX-License-Identifier: GPL-2.0
aufs6.12 mmap patch

diff --git a/fs/Makefile b/fs/Makefile
index b2539712b80d0..8260694bb133a 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -16,6 +16,9 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		stack.o fs_struct.o statfs.o fs_pin.o nsfs.o \
 		fs_types.o fs_context.o fs_parser.o fsopen.o init.o \
 		kernel_read_file.o mnt_idmapping.o remap_range.o pidfs.o
+ifeq (${CONFIG_AUFS_FS},m)
+obj-y += au_mf.o
+endif
 
 obj-$(CONFIG_BUFFER_HEAD)	+= buffer.o mpage.o
 obj-$(CONFIG_PROC_FS)		+= proc_namespace.o
diff --git a/fs/au_mf.c b/fs/au_mf.c
new file mode 100644
index 0000000000000..ee1ff03778b98
--- /dev/null
+++ b/fs/au_mf.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2025 Junjiro R. Okajima
+ */
+
+#include <linux/fs.h>
+#include <linux/module.h>
+
+#if IS_MODULE(CONFIG_AUFS_FS)
+/*
+ * This au_mf.c (aufs mmapped files) is for external AUFS module only,
+ * and statically linked to kernel.
+ * See also $srctree/fs/Makefile.
+ * This linking may seem to be tricky. It is due to support the case when AUFS
+ * is configured as an external module, eg. VFS calls a function defined in the
+ * dynamic module.
+ */
+#else
+BUILD_BUG_ON_MSG(1, "CONFIG_AUFS_FS is disabled.");
+#endif
+
+const struct path *au_file_user_path(struct file *f)
+{
+	const struct path *path,
+		*(*func)(struct file *f),
+		*au_do_file_user_path(struct file *f);
+
+	path = NULL;
+	func = symbol_get(au_do_file_user_path);
+	if (unlikely(!func))
+		/* "aufs" module is not loaded */
+		goto out;
+
+	path = func(f);
+	symbol_put(au_do_file_user_path);
+
+out:
+	return path;
+}
+EXPORT_SYMBOL_GPL(au_file_user_path);
+
+const struct inode *au_file_user_inode(struct file *f)
+{
+	const struct inode *inode,
+		*(*func)(struct file *f),
+		*au_do_file_user_inode(struct file *f);
+
+	inode = NULL;
+	func = symbol_get(au_do_file_user_inode);
+	if (unlikely(!func))
+		/* "aufs" module is not loaded */
+		goto out;
+
+	inode = func(f);
+	symbol_put(au_do_file_user_inode);
+
+out:
+	return inode;
+}
+EXPORT_SYMBOL_GPL(au_file_user_inode);
diff --git a/fs/proc/base.c b/fs/proc/base.c
index b31283d81c52e..d738243b88746 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1784,7 +1784,7 @@ static int proc_exe_link(struct dentry *dentry, struct path *exe_path)
 	exe_file = get_task_exe_file(task);
 	put_task_struct(task);
 	if (exe_file) {
-		*exe_path = exe_file->f_path;
+		*exe_path = *file_user_path(exe_file);
 		path_get(&exe_file->f_path);
 		fput(exe_file);
 		return 0;
diff --git a/fs/proc/nommu.c b/fs/proc/nommu.c
index c6e7ebc637562..12c340dcdec3d 100644
--- a/fs/proc/nommu.c
+++ b/fs/proc/nommu.c
@@ -39,7 +39,7 @@ static int nommu_region_show(struct seq_file *m, struct vm_region *region)
 	file = region->vm_file;
 
 	if (file) {
-		struct inode *inode = file_inode(region->vm_file);
+		struct inode *inode = file_user_inode(region->vm_file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index bce6745330003..dac36cc7a3880 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -137,7 +137,7 @@ static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma)
 	file = vma->vm_file;
 
 	if (file) {
-		struct inode *inode = file_inode(vma->vm_file);
+		struct inode *inode = file_user_inode(vma->vm_file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51b64b2ad82c4..0ecfff8ca9412 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2734,6 +2734,21 @@ struct file *dentry_create(const struct path *path, int flags, umode_t mode,
 			   const struct cred *cred);
 struct path *backing_file_user_path(struct file *f);
 
+#if IS_MODULE(CONFIG_AUFS_FS)
+/* fs/au_mf.c */
+const struct path *au_file_user_path(struct file *f);
+const struct inode *au_file_user_inode(struct file *f);
+#elif IS_BUILTIN(CONFIG_AUFS_FS)
+/* fs/aufs/mf.c */
+const struct path *au_do_file_user_path(struct file *f);
+const struct inode *au_do_file_user_inode(struct file *f);
+#define au_file_user_path(f)	au_do_file_user_path(f)
+#define au_file_user_inode(f)	au_do_file_user_inode(f)
+#else
+#define au_file_user_path(f)	NULL
+#define au_file_user_inode(f)	NULL
+#endif
+
 /*
  * When mmapping a file on a stackable filesystem (e.g., overlayfs), the file
  * stored in ->vm_file is a backing file whose f_inode is on the underlying
@@ -2746,15 +2761,25 @@ struct path *backing_file_user_path(struct file *f);
 /* Get the path to display in /proc/<pid>/maps */
 static inline const struct path *file_user_path(struct file *f)
 {
+	const struct path *path;
+
 	if (unlikely(f->f_mode & FMODE_BACKING))
 		return backing_file_user_path(f);
+	path = au_file_user_path(f);
+	if (path)
+		return path;
 	return &f->f_path;
 }
 /* Get the inode whose inode number to display in /proc/<pid>/maps */
 static inline const struct inode *file_user_inode(struct file *f)
 {
+	const struct inode *inode;
+
 	if (unlikely(f->f_mode & FMODE_BACKING))
 		return d_inode(backing_file_user_path(f)->dentry);
+	inode = au_file_user_inode(f);
+	if (inode)
+		return inode;
 	return file_inode(f);
 }
 
